{
  "metadata": {
    "title": "Working with Files",
    "subtitle": "Reading and writing text files in Python",
    "description": "Learn to open, read, write, and close text files; use the with statement; work with file paths and line-by-line processing.",
    "version": "1.0.0",
    "author": "EduCafé",
    "lastUpdated": "2026-02-05",
    "storageKeyPrefix": "working_with_files",
    "instructorPasscode": "educafe-files-101",
    "order": 10
  },
  "branding": {
    "brandName": "EduCafé — Python Guide",
    "theme": {
      "colorScheme": "dark",
      "primaryColor": "#4aa3ff",
      "secondaryColor": "#7bc67b"
    }
  },
  "stages": [
    {"id": "s0", "order": 0, "title": "Stage 0 · Starting", "shortTitle": "Starting", "description": "Introduction to file I/O"},
    {"id": "s1", "order": 1, "title": "Stage 1 · Remembering", "shortTitle": "Remembering", "description": "Vocabulary for reading and writing files"},
    {"id": "s2", "order": 2, "title": "Stage 2 · Understanding", "shortTitle": "Understanding", "description": "How file I/O works"},
    {"id": "s3", "order": 3, "title": "Stage 3 · Applying", "shortTitle": "Applying", "description": "Writing programs that read and write files"},
    {"id": "s4", "order": 4, "title": "Stage 4 · Analyzing", "shortTitle": "Analyzing", "description": "Troubleshooting file errors"},
    {"id": "s5", "order": 5, "title": "Stage 5 · Evaluating", "shortTitle": "Evaluating", "description": "Judging file I/O design and quality"},
    {"id": "s6", "order": 6, "title": "Stage 6 · Creating", "shortTitle": "Creating", "description": "Original projects with files"}
  ],
  "sections": [
    {"id": "mindset", "displayName": "Mindset", "order": 0, "description": "Prepare mentally"},
    {"id": "recap", "displayName": "Recap", "order": 1, "description": "Connect to prior learning"},
    {"id": "core", "displayName": "Core", "order": 2, "description": "Main content"},
    {"id": "guidedPractice", "displayName": "Guided Practice", "order": 3, "description": "Practice with help"},
    {"id": "challenge", "displayName": "Challenge", "order": 4, "description": "Independent work"},
    {"id": "reflection", "displayName": "Reflection", "order": 5, "description": "Think about learning"},
    {"id": "transition", "displayName": "Transition", "order": 6, "description": "Move forward"}
  ],
  "content": {
    "s0": {
      "mindset": {
        "heading": "Your Programs Can Save and Load Data",
        "components": [
          {"type": "text", "content": "You're about to learn **working with files** — how to read from and write to text files in Python. Until now, everything your programs used lived in memory and disappeared when the program ended. With file I/O, you can save data to disk, load it back, share it with other programs, and build tools that persist information."},
          {"type": "text", "content": "Every expert programmer uses files: configs, logs, reports, and data. Once you master file I/O, you'll build programs that matter — from simple note-takers to tools that process real data."}
        ]
      },
      "recap": {
        "heading": "Building on What You Know",
        "components": [
          {"type": "text", "content": "You already know how to:\n- Use strings, variables, and loops\n- Define and call functions\n- Work with lists and other collections\n\nEverything so far lived **in memory**. Now you'll use **files** — data stored on disk. Your programs will open a file, read or write its contents (often as strings or lines), and close it. You'll combine file I/O with the skills you already have."}
        ]
      },
      "core": {
        "heading": "What Is File I/O?",
        "components": [
          {"type": "text", "content": "**File I/O** (input/output) means reading data from files and writing data to files. Python gives you a simple pattern: **open** a file (you get a file object), **read** or **write** using that object, then **close** it so the system can release resources. For text files, you work with strings and lines — the same types you already use."},
          {"type": "text", "content": "**Real-World Examples:**\n\n• **Config files** — Programs read settings from a .txt or .ini file so you can change behavior without editing code.\n• **Logs** — Applications append lines to a log file to record what happened (errors, events, user actions).\n• **CSV-like data** — Spreadsheet data or lists saved as lines; read them, process with loops, write results back.\n• **Notes and to-do lists** — Save and load plain text so data persists between runs.\n• **Save data** — Games or tools save progress (e.g., scores, state) to a file and load it next time.\n• **Reports** — Generate a text report and write it to a file for sharing or printing.\n• **Templates** — Read a template file, fill in values, write the result to a new file."},
          {"type": "text", "content": "**Visual Metaphors:**\n\n**File as a notebook** — You open it (open), read a page or the whole thing (read), write on a page (write), then close it (close). Until you close, other programs might not see your changes or you might tie up the file.\n\n**Reading as a cursor** — When you read, Python moves a \"cursor\" through the file. read() gets everything from the cursor to the end; readline() gets one line; readlines() gets all lines as a list. After a full read(), the cursor is at the end, so another read() returns an empty string.\n\n**Writing as appending or overwriting** — You can open for writing (\"w\" — creates or overwrites) or appending (\"a\" — adds to the end). Choosing the right mode prevents accidentally wiping data."},
          {"type": "text", "content": "**Why closing and `with` matter:** If you open a file and never close it, the program may hold the file open (other programs can't change it, and buffers might not be written to disk). Python's **with** statement opens the file, lets you use it, and **automatically closes** it when the block ends — even if an error occurs. Professional code almost always uses `with` for files."},
          {"type": "text", "content": "**Connection to prior knowledge:** You already use strings — file contents are strings (or lists of strings for lines). You already use loops — you'll loop over lines. You already use functions — you'll write functions that take a path and return file contents, or write data to a file. File I/O is the next step: same data types, new source and destination."},
          {"type": "code", "language": "python", "content": "# Pattern you'll learn: open → use → close\nwith open(\"notes.txt\", \"r\") as f:\n    text = f.read()\n# file is closed automatically\nprint(text)", "copyable": false}
        ]
      },
      "guidedPractice": {
        "heading": "Exploring File I/O",
        "components": [
          {"type": "multipleChoice", "question": "When would a program use file I/O instead of only variables in memory?", "options": ["To run faster", "To save data so it persists after the program ends", "To avoid using strings", "To replace loops"], "correctIndex": 1, "feedback": {"correct": "Correct! Files let data persist on disk after the program stops.", "incorrect": "File I/O is used when you need to save or load data from disk so it persists."}},
          {"type": "shortAnswer", "prompt": "Name one real-world program or app that reads or writes files. What kind of file does it use?", "validation": {"type": "freeform"}},
          {"type": "multipleChoice", "question": "What does the with statement do for files?", "options": ["Makes reading faster", "Opens the file and automatically closes it when done", "Writes only one line", "Replaces the need for paths"], "correctIndex": 1, "feedback": {"correct": "Correct! with opens the file and ensures it is closed when the block ends.", "incorrect": "The with statement opens the file and automatically closes it when you leave the block, even if an error occurs."}},
          {"type": "shortAnswer", "prompt": "Why might accidentally opening a file with mode \"w\" (write) be a problem?", "validation": {"type": "freeform"}}
        ]
      },
      "challenge": {
        "heading": "Think About Files",
        "components": [
          {"type": "multipleChoice", "question": "What's the best way to store 100 quiz scores so you can load them next time the program runs?", "options": ["Keep them in a variable only", "Write them to a text file and read the file next run", "Use a dictionary only", "Print them to the screen"], "correctIndex": 1, "feedback": {"correct": "Correct! Writing to a file lets you load the scores next time.", "incorrect": "To persist data between runs, you need to write to a file and read from it later."}},
          {"type": "shortAnswer", "prompt": "Describe one program you'd like to build that would read or write a file. What would the file contain?", "validation": {"type": "freeform"}}
        ]
      },
      "reflection": {
        "heading": "Preparing for Learning",
        "components": [
          {"type": "checklist", "items": ["I understand what file I/O is (reading and writing files)", "I can name at least two examples of programs that use files", "I'm ready to learn the vocabulary (open, read, write, close, with, path)"]},
          {"type": "shortAnswer", "prompt": "On a scale of 1-10, how excited are you to learn file I/O? What would make it a 10?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "What are you most curious about regarding files? What questions do you have?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "How do you think saving and loading data will help you build better programs?", "validation": {"type": "freeform"}}
        ]
      },
      "transition": {
        "heading": "Ready to Learn",
        "components": [
          {"type": "text", "content": "You've learned **what file I/O is** and **why it matters** — persistence, sharing data, automation.\n\n**Why this matters:** Programs that read and write files are more useful and realistic.\n\n**How you'll use this:** You'll learn the vocabulary — **open()**, **file object**, **file mode**, **read()**, **readlines()**, **write()**, **close()**, **with**, **path** — and then how they work together. Next: the terms and syntax for working with files."}
        ]
      }
    },
    "s1": {
      "mindset": {
        "heading": "Learning the Language",
        "components": [
          {"type": "text", "content": "You're moving from the idea of file I/O to the specific vocabulary. Right now you're learning the terms and syntax that will let you open, read, write, and close files confidently."}
        ]
      },
      "recap": {
        "heading": "What You Remember",
        "components": [
          {"type": "text", "content": "From Stage 0, you know that file I/O means reading from and writing to text files, and that we open, use, then close. Now you'll learn the precise terms: open(), file object, file mode, read(), readline(), readlines(), write(), writelines(), close(), with statement, path, and newline."}
        ]
      },
      "core": {
        "heading": "Key Vocabulary for File I/O",
        "components": [
          {"type": "text", "content": "**open()** — Built-in function that opens a file and returns a file object. Example: open(\"data.txt\", \"r\"). When it matters: First step for any file I/O. Connection: Takes a path and optional mode; use with for automatic close."},
          {"type": "text", "content": "**file object** — The value returned by open(). You call read(), write(), close() on it. Example: f = open(\"x.txt\"); f.read(). When it matters: This is your handle to the file. Connection: Use it only inside the with block or remember to close()."},
          {"type": "text", "content": "**file mode** — String that tells open() how to use the file. \"r\" = read (default), \"w\" = write (creates or overwrites), \"a\" = append (add to end). Example: open(\"log.txt\", \"a\"). When it matters: Wrong mode causes errors or data loss. Connection: \"r\" requires file to exist; \"w\" and \"a\" create if missing."},
          {"type": "text", "content": "**read()** — Method on a file object; returns the entire file contents as one string. Example: content = f.read(). When it matters: Use for small files or when you need the whole text. Connection: After read(), cursor is at end; another read() returns \"\"."},
          {"type": "text", "content": "**readline()** — Method that returns one line (including newline) or \"\" at end. Example: line = f.readline(). When it matters: Process a file line by line without loading all into memory. Connection: Repeated calls read successive lines."},
          {"type": "text", "content": "**readlines()** — Method that returns a list of lines (each includes newline). Example: lines = f.readlines(). When it matters: Get all lines as a list for looping or processing. Connection: Like read() but split into lines."},
          {"type": "text", "content": "**write()** — Method that writes a string to the file. Does not add a newline automatically. Example: f.write(\"hello\"). When it matters: Use \"w\" or \"a\" mode; add \\n for new lines. Connection: writelines() writes a list of strings."},
          {"type": "text", "content": "**writelines()** — Method that writes a list of strings to the file; does not add newlines. Example: f.writelines([\"a\\n\", \"b\\n\"]). When it matters: Write multiple lines at once. Connection: You must include \\n in each string if you want line breaks."},
          {"type": "text", "content": "**close()** — Method that closes the file and releases resources. Example: f.close(). When it matters: If you don't use with, you must close() to avoid leaks and ensure data is written. Connection: with closes automatically."},
          {"type": "text", "content": "**with statement** — Context manager: with open(path, mode) as f: ... ensures the file is closed when the block ends. Example: with open(\"x.txt\") as f: print(f.read()). When it matters: Best practice for files; safe even on errors. Connection: Use instead of manual open/close when possible."},
          {"type": "text", "content": "**path** — Location of the file. Relative path is relative to current working directory (e.g. \"data.txt\"); absolute path is full (e.g. \"C:\\\\Users\\\\You\\\\data.txt\" on Windows). When it matters: Wrong path causes FileNotFoundError. Connection: open(path) uses this."},
          {"type": "text", "content": "**newline** — The character (or two) that ends a line (\\\\n in Python). When it matters: readline() and readlines() include it; write() does not add it — add \\n yourself. Connection: Without \\n, write() puts everything on one line."}
        ]
      },
      "guidedPractice": {
        "heading": "Vocabulary Practice",
        "components": [
          {"type": "matching", "leftColumn": ["open()", "file object", "file mode", "read()", "readlines()", "write()", "close()", "with statement", "path", "newline"], "rightColumn": [
            {"definition": "Built-in that opens a file and returns a file object", "matchesWith": "open()"},
            {"definition": "The value returned by open(); you call read/write/close on it", "matchesWith": "file object"},
            {"definition": "String like \"r\", \"w\", \"a\" that says how to use the file", "matchesWith": "file mode"},
            {"definition": "Returns entire file contents as one string", "matchesWith": "read()"},
            {"definition": "Returns a list of lines from the file", "matchesWith": "readlines()"},
            {"definition": "Writes a string to the file; does not add newline", "matchesWith": "write()"},
            {"definition": "Releases the file and flushes buffers", "matchesWith": "close()"},
            {"definition": "Ensures file is closed when block ends", "matchesWith": "with statement"},
            {"definition": "Location of the file (relative or absolute)", "matchesWith": "path"},
            {"definition": "Character that ends a line; \\n in Python", "matchesWith": "newline"}
          ]},
          {"type": "ordering", "instructions": "Put these steps in the correct order for reading a file.", "items": ["Open the file with open(path, \"r\")", "Read content (e.g. f.read() or f.readlines())", "Close the file (or use with so it closes automatically)"], "correctOrder": [0, 1, 2]},
          {"type": "multipleChoice", "question": "What is the default mode of open(\"file.txt\")?", "options": ["\"w\"", "\"r\"", "\"a\"", "\"x\""], "correctIndex": 1, "feedback": {"correct": "Correct! The default mode is \"r\" (read).", "incorrect": "The default mode is \"r\" for read. You must specify \"w\" or \"a\" to write."}}
        ]
      },
      "challenge": {
        "heading": "Vocabulary Application",
        "components": [
          {"type": "text", "content": "**Creative task:** Draw or describe the flow from \"file on disk\" to \"variable in code\". Include: open, read (or readlines), close."},
          {"type": "shortAnswer", "prompt": "What is the main difference between read() and readlines()? When might you use each?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "What is the default mode when you call open(\"data.txt\") with no second argument?", "validation": {"type": "contains", "acceptedAnswers": ["r", "read"]}}
        ]
      },
      "reflection": {
        "heading": "Vocabulary Check",
        "components": [
          {"type": "checklist", "items": ["I can define open(), file object, file mode, read(), readlines(), write(), close(), with, path", "I can recall what read() vs readlines() return", "I understand how these terms work together"]},
          {"type": "shortAnswer", "prompt": "Which term was easiest for you? Which needs more review?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "How does knowing the file mode (r, w, a) help you avoid mistakes?", "validation": {"type": "freeform"}}
        ]
      },
      "transition": {
        "heading": "From Terms to Understanding",
        "components": [
          {"type": "text", "content": "You've learned the vocabulary: **open()**, **file object**, **file mode**, **read()**, **readline()**, **readlines()**, **write()**, **writelines()**, **close()**, **with**, **path**, **newline**.\n\n**Why this matters:** Knowing the terms is the first step. Now you'll understand **how** Python opens a file, reads (moving a cursor), writes, and closes — and why with and mode choice matter.\n\n**How you'll use this:** Next, you'll see the step-by-step process behind file I/O so you can use it correctly and fix problems."}
        ]
      }
    },
    "s2": {
      "mindset": {
        "heading": "Understanding the Process",
        "components": [
          {"type": "text", "content": "You're moving from knowing the terms to understanding **how** file I/O actually works: what happens when you open, how reading moves a cursor, why close and with matter, and how paths are resolved."}
        ]
      },
      "recap": {
        "heading": "What You Know",
        "components": [
          {"type": "text", "content": "You know the vocabulary: open(), file object, modes, read(), readlines(), write(), close(), with, path. Now you'll see how Python uses these when you open, read, write, or close a file."}
        ]
      },
      "core": {
        "heading": "How File I/O Works",
        "components": [
          {"type": "text", "content": "**Step 1: open(path, mode)** — Python finds the file at the given path (relative to current directory or absolute). It creates a file object and prepares it for reading or writing based on mode. If the file doesn't exist and mode is \"r\", you get FileNotFoundError; with \"w\" or \"a\", Python creates the file if needed."},
          {"type": "text", "content": "**Step 2: Mode determines behavior** — \"r\" (read): you can only read; file must exist. \"w\" (write): creates or **overwrites** the file; previous content is lost. \"a\" (append): creates or opens and **adds** at the end; existing content stays."},
          {"type": "text", "content": "**Step 3: Reading moves a cursor** — The file object has an internal position. read() returns everything from that position to the end and moves the cursor to the end. readline() returns one line (including \\n) and moves the cursor to the next line. readlines() reads all remaining lines into a list. After a full read(), another read() returns an empty string."},
          {"type": "text", "content": "**Step 4: read() vs readline() vs readlines()** — read() → one string (whole file). readline() → one line per call. readlines() → list of lines (each usually ends with \\n). For line-by-line processing without loading all: use for line in f: (or readline() in a loop). For small files, read() or readlines() is fine."},
          {"type": "text", "content": "**Step 5: write() and newlines** — write(s) writes the string s to the file. It does **not** add a newline. So write(\"line1\"); write(\"line2\") puts \"line1line2\" in the file. You must add \\n: write(\"line1\\n\"); write(\"line2\\n\"). writelines(list) writes each string in the list; again, include \\n in each if you want line breaks."},
          {"type": "text", "content": "**Step 6: Why close() matters** — Data may be buffered in memory; close() flushes buffers and releases the file so other programs can use it. If you don't close, long-running programs can leak resources, and on some systems your writes might not appear until close."},
          {"type": "text", "content": "**Step 7: What with does** — with open(path, mode) as f: ... runs the block with f as the file object. When the block ends (normally or by exception), Python automatically calls f.close(). So you never forget to close, and you avoid leaks and incomplete writes."},
          {"type": "text", "content": "**Step 8: Relative vs absolute path** — Relative path (e.g. \"data.txt\") is relative to the **current working directory** (where you ran the script). Absolute path (e.g. C:\\\\Users\\\\You\\\\data.txt) is independent of where you run from. Wrong path → FileNotFoundError."},
          {"type": "text", "content": "**Step 9: Line-by-line loop** — for line in f: reads the file line by line without loading all into memory. line includes the newline. This is a common pattern for large files."},
          {"type": "text", "content": "**Key idea:** Open → use (read/write) → close. Use with so close is automatic. Choose the right mode and add \\n when writing lines."},
          {"type": "code", "language": "python", "content": "with open(\"example.txt\", \"r\") as f:\n    content = f.read()\nwith open(\"output.txt\", \"w\") as f:\n    f.write(\"first line\\n\")\n    f.write(\"second line\\n\")", "copyable": false}
        ]
      },
      "guidedPractice": {
        "heading": "Understanding the Flow",
        "components": [
          {"type": "shortAnswer", "prompt": "Why does a second f.read() return an empty string after you've already read the whole file?", "validation": {"type": "freeform"}},
          {"type": "multipleChoice", "question": "What does open(\"x.txt\", \"w\") do if x.txt already exists?", "options": ["Appends to it", "Raises an error", "Overwrites it", "Opens for read only"], "correctIndex": 2, "feedback": {"correct": "Correct! Mode \"w\" overwrites the file.", "incorrect": "\"w\" mode creates the file or overwrites existing content. Use \"a\" to append."}},
          {"type": "multipleChoice", "question": "What will f.write(\"a\") and f.write(\"b\") put in the file?", "options": ["a then b on two lines", "ab on one line", "Only b", "Error"], "correctIndex": 1, "feedback": {"correct": "Correct! write() does not add newlines; you get \"ab\".", "incorrect": "write() does not add a newline, so the file contains \"ab\" on one line."}},
          {"type": "shortAnswer", "prompt": "When would you use \"a\" mode instead of \"w\"? Give one example.", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "Explain in one sentence what the with statement does for file handling.", "validation": {"type": "freeform"}}
        ]
      },
      "challenge": {
        "heading": "Create a Flow Diagram",
        "components": [
          {"type": "text", "content": "**Creative task:** Create a flowchart or diagram showing the flow from \"file path\" to \"lines in memory\". Include: open, read or readlines, close (or with)."},
          {"type": "shortAnswer", "prompt": "Describe your diagram. How does it show when data is read and when the file is closed?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "When would you prefer using with instead of manually calling close()? Why?", "validation": {"type": "freeform"}}
        ]
      },
      "reflection": {
        "heading": "Understanding Check",
        "components": [
          {"type": "checklist", "items": ["I can explain how open, read, and close work together", "I can describe why write() doesn't add newlines and what to do", "I understand what with does and why it's recommended"]},
          {"type": "shortAnswer", "prompt": "What was the most surprising thing about how file I/O works?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "How does understanding the cursor (position) help you avoid bugs when reading?", "validation": {"type": "freeform"}}
        ]
      },
      "transition": {
        "heading": "From Understanding to Doing",
        "components": [
          {"type": "text", "content": "You understand **how** file I/O works — open, modes, cursor, read/write, close, and with.\n\n**Why this matters:** Understanding the process helps you write correct file code and choose the right mode and methods.\n\n**How you'll use this:** Next, you'll **apply** this by writing your own scripts: create a sample file, open with with, read and print, write and append, and verify in the editor or terminal."}
        ]
      }
    },
    "s3": {
      "mindset": {
        "heading": "Time to Code",
        "components": [
          {"type": "text", "content": "You're moving from understanding to **doing**. Now you'll write your own file I/O code. Focus on using with, the right mode, and adding \\n when writing lines. Mistakes are normal — that's how you learn!"}
        ]
      },
      "recap": {
        "heading": "Before You Start",
        "components": [
          {"type": "text", "content": "You understand how open, read, write, close, and with work. Now let's write file code! Can you answer: How do you open for reading? For writing? Why use with?"}
        ]
      },
      "core": {
        "heading": "Writing File I/O Code: Step-by-Step",
        "components": [
          {"type": "text", "content": "**Preparation checklist**\n\n✓ Python installed; text editor and terminal ready\n✓ A folder for your scripts and sample files\n✓ You know strings, loops, and functions\n✓ You understand file vocabulary (open, mode, read, write, with)\n\nOnce you've checked these, you're ready to write file code!"},
          {"type": "text", "content": "**Step-by-step: Your first read**\n\n**Step 1:** Create a plain text file (e.g. notes.txt) with 2–3 lines and save it in the same folder as your script.\n**Step 2:** Create a new Python file (e.g. file_demo.py).\n**Step 3:** Use with open(\"notes.txt\", \"r\") as f:\n**Step 4:** Inside the block: content = f.read() then print(content).\n**Step 5:** Run the script from the folder that contains notes.txt; confirm the output.\n\n**Step-by-step: Your first write**\n\n**Step 1:** With the same script (or a new one), use with open(\"output.txt\", \"w\") as f:\n**Step 2:** f.write(\"Hello\\\\n\"); f.write(\"World\\\\n\").\n**Step 3:** Run the script; open output.txt in an editor and confirm two lines.\n\n**Step-by-step: Append**\n\n**Step 1:** Use with open(\"output.txt\", \"a\") as f:\n**Step 2:** f.write(\"Appended line\\\\n\").\n**Step 3:** Run again; confirm the new line is at the end of output.txt."},
          {"type": "text", "content": "**Common pitfalls and how to avoid them**\n\n1. **Wrong mode** — Using \"r\" when the file doesn't exist → FileNotFoundError. Fix: Use \"w\" or \"a\" to create, or check if file exists.\n2. **Forgetting newline** — write(\"line1\"); write(\"line2\") → one long line. Fix: write(\"line1\\\\n\") etc.\n3. **Not using with** — Forgetting close() can leak resources. Fix: Prefer with open(...) as f:\n4. **Path typo** — Wrong filename or path → FileNotFoundError. Fix: Use the exact path; run from the correct directory.\n5. **Reading after full read()** — Second f.read() returns \"\". Fix: Store result in a variable and reuse it, or open again.\n6. **Overwriting with \"w\"** — \"w\" wipes the file. Fix: Use \"a\" if you want to add without losing content.\n7. **Encoding** — For non-ASCII text, open(path, \"r\", encoding=\"utf-8\"). Fix: Specify encoding when needed.\n8. **Windows vs Unix paths** — Use \"path\\\\to\\\\file\" or path/to/file; Python accepts forward slashes on Windows too.\n9. **Writing then reading same file** — Open with \"w\", write, then read in same block: read returns \"\" because cursor is at end. Fix: Close and reopen, or use two with blocks."},
          {"type": "text", "content": "**Verification**\n\n• After reading: print the content; check it matches the file.\n• After writing: open the file in an editor; confirm lines and newlines.\n• Run from the directory that contains the file (or use correct relative/absolute path)."},
          {"type": "code", "language": "python", "content": "with open(\"notes.txt\", \"r\") as f:\n    text = f.read()\nprint(text)\n\nwith open(\"output.txt\", \"w\") as f:\n    f.write(\"first\\n\")\n    f.write(\"second\\n\")", "copyable": true},
          {"type": "code", "language": "python", "content": "with open(\"output.txt\", \"a\") as f:\n    f.write(\"appended\\n\")", "copyable": true}
        ]
      },
      "guidedPractice": {
        "heading": "Practice Writing File Code",
        "components": [
          {"type": "checklist", "items": ["I have Python and a text editor ready", "I created a folder and a sample .txt file", "I know the difference between \"r\", \"w\", and \"a\"", "I remember to add \\n when writing lines"]},
          {"type": "text", "content": "**Activity:** Create file_practice.py. Open a small .txt file with with and read(); print its contents. Then open another file with \"w\" and write 3 lines (with \\n). Open the written file in an editor to verify."},
          {"type": "shortAnswer", "prompt": "What happens if you open a file with \"w\" and the file already has content? Why?", "validation": {"type": "freeform"}},
          {"type": "multipleChoice", "question": "What is wrong with: with open(\"x.txt\") as f: f.write(\"hi\")?", "options": ["Nothing", "Default mode is \"r\"; you cannot write", "Missing newline", "Path is wrong"], "correctIndex": 1, "feedback": {"correct": "Correct! Default mode is \"r\"; use \"w\" or \"a\" to write.", "incorrect": "The default mode is \"r\" (read). You need open(\"x.txt\", \"w\") to write."}},
          {"type": "multipleChoice", "question": "How do you ensure the file is closed even if an error occurs?", "options": ["Call close() in a loop", "Use the with statement", "Use read() only", "Use \"a\" mode"], "correctIndex": 1, "feedback": {"correct": "Correct! with automatically closes the file when the block ends.", "incorrect": "The with statement ensures the file is closed when the block exits, even on errors."}}
        ]
      },
      "challenge": {
        "heading": "Create a File I/O Program",
        "components": [
          {"type": "text", "content": "**Proof-of-work:** Create files_practice.py that:\n\n1. Reads a text file (create one with 2–3 lines if needed) using with and read() or readlines(), and prints the content.\n2. Writes to another file (e.g. result.txt) using with and \"w\", writing at least 2 lines (with \\n).\n3. Optionally: append one more line using \"a\".\n\n**Requirements:** File named files_practice.py; run without errors; paste your code and a sample of the output (or describe what you see in the written file)."},
          {"type": "shortAnswer", "prompt": "What was the most challenging part of writing your file program? How did you solve it?", "validation": {"type": "freeform"}}
        ]
      },
      "reflection": {
        "heading": "Application Check",
        "components": [
          {"type": "checklist", "items": ["I can open a file with with and read its contents", "I can write and append to files with correct newlines", "I can run my script and verify the file contents", "I can fix common mistakes (mode, path, newline)"]},
          {"type": "shortAnswer", "prompt": "What was the easiest part? What was the most confusing?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "How confident do you feel reading and writing files now? What would help?", "validation": {"type": "freeform"}}
        ]
      },
      "transition": {
        "heading": "From Writing to Troubleshooting",
        "components": [
          {"type": "text", "content": "You can now **write file I/O code** — open with with, read, write, append, and verify. You're ready to **analyze and troubleshoot** when something goes wrong: FileNotFoundError, wrong mode, path issues, and other common file errors."}
        ]
      }
    },
    "s4": {
      "mindset": {
        "heading": "Becoming a Troubleshooter",
        "components": [
          {"type": "text", "content": "You're moving from writing correct file code to understanding what goes wrong. Every FileNotFoundError or UnsupportedOperation is a clue. Check path, mode, and whether you closed (or used with)."}
        ]
      },
      "recap": {
        "heading": "What Works",
        "components": [
          {"type": "text", "content": "You know how to read and write files with with. Now we'll look at what happens when it doesn't work — and how to fix it."}
        ]
      },
      "core": {
        "heading": "Troubleshooting File Errors",
        "components": [
          {"type": "text", "content": "**Error 1: FileNotFoundError — No such file or directory**\n**Symptom:** FileNotFoundError when opening with \"r\"\n**Possible cause:** File doesn't exist or path is wrong (typo, wrong folder)\n**How to verify:** Check file exists in the folder you're running from; print the path; use absolute path to test\n**How to fix:** Create the file, fix the path, or use \"w\"/\"a\" to create it\n\n**Error 2: PermissionError**\n**Symptom:** PermissionError when opening or writing\n**Possible cause:** File is open elsewhere, read-only, or no write permission\n**How to verify:** Close other programs using the file; check folder permissions\n**How to fix:** Close the file elsewhere; run from a folder you can write to\n\n**Error 3: Wrong mode — UnsupportedOperation: not readable/writable**\n**Symptom:** UnsupportedOperation when calling read() on a file opened with \"w\" or write() on \"r\"\n**Possible cause:** Opened for write but trying to read, or opened for read but trying to write\n**How to verify:** Check open(..., \"r\") vs \"w\" vs \"a\"\n**How to fix:** Use the correct mode; open again with the right mode if needed\n\n**Error 4: Not closing / not using with**\n**Symptom:** Data not appearing in file; file locked; resource leak\n**Possible cause:** Forgot close() or didn't use with\n**How to verify:** Look for open() without with and no close()\n**How to fix:** Use with open(...) as f: so file closes automatically\n\n**Error 5: Path typo or wrong slashes**\n**Symptom:** FileNotFoundError even though file exists\n**Possible cause:** Typo in name; wrong directory; backslashes need escaping or use raw string\n**How to verify:** Print path; list directory with os.listdir('.')\n**How to fix:** Correct spelling; run from the right folder; use forward slashes or r\"path\\\\to\\\\file\"\n\n**Error 6: Encoding / Unicode**\n**Symptom:** UnicodeDecodeError when reading; odd characters when writing\n**Possible cause:** File is UTF-8 or other encoding; default may differ on Windows\n**How to verify:** Open file in editor and check encoding\n**How to fix:** open(path, \"r\", encoding=\"utf-8\") (or the correct encoding)\n\n**Error 7: Empty read after full read**\n**Symptom:** Second f.read() returns \"\"\n**Possible cause:** Cursor at end after first read\n**How to verify:** Store first result in variable; don't read twice\n**How to fix:** Reuse the stored string or open the file again\n\n**Error 8: Writing without newline — one long line**\n**Symptom:** All content on one line in the file\n**Possible cause:** write() doesn't add \\n\n**How to verify:** Check each write() call\n**How to fix:** Add \\n: write(\"line\\\\n\")\n\n**Systematic troubleshooting:** (1) Read the error message and type (FileNotFoundError, PermissionError, UnsupportedOperation). (2) Find the line (which open or read/write). (3) For FileNotFoundError: check path and current directory. (4) For UnsupportedOperation: check mode. (5) For missing data: check with/close and newlines."},
          {"type": "code", "language": "python", "content": "# FileNotFoundError: file missing with \"r\"\n# with open(\"missing.txt\", \"r\") as f:  # fails\n# Fix: create file or use \"w\"/\"a\"\n\n# UnsupportedOperation: read on \"w\"\n# with open(\"x.txt\", \"w\") as f:\n#     print(f.read())  # fails\n# Fix: use \"r\" to read", "copyable": false}
        ]
      },
      "guidedPractice": {
        "heading": "Error Diagnosis Practice",
        "components": [
          {"type": "text", "content": "**Activity:** This code raises an error. What's wrong?\n\nwith open(\"data.txt\") as f:\n    f.write(\"hello\\\\n\")"},
          {"type": "shortAnswer", "prompt": "What error does the code above cause? How do you fix it?", "validation": {"type": "contains", "acceptedAnswers": ["UnsupportedOperation", "write", "r", "read", "mode", "w"]}},
          {"type": "multipleChoice", "question": "You get FileNotFoundError for \"notes.txt\". What should you check first?", "options": ["The mode", "Whether the file exists and the path is correct", "Whether you used with", "The encoding"], "correctIndex": 1, "feedback": {"correct": "Correct! Check that the file exists and the path is right (and you're in the right directory).", "incorrect": "FileNotFoundError means the file wasn't found — check path and current directory."}},
          {"type": "shortAnswer", "prompt": "Write a 3-step process you would use to debug FileNotFoundError.", "validation": {"type": "freeform"}},
          {"type": "ordering", "instructions": "Order these debugging steps for a file write that didn't appear.", "items": ["Check that you used with or called close()", "Check the path and current directory", "Check that you used mode \"w\" or \"a\""], "correctOrder": [2, 1, 0]}
        ]
      },
      "challenge": {
        "heading": "Create a Troubleshooting Flowchart",
        "components": [
          {"type": "text", "content": "**Creative task:** Create a small flowchart for debugging file errors. Include: File error → path correct? → mode correct? → using with / close?"},
          {"type": "shortAnswer", "prompt": "Describe your flowchart. What do you check first when you get a file error?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "For FileNotFoundError, what are two things you would verify?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "A script writes to output.txt but the file is empty. What's the first question you'd ask?", "validation": {"type": "freeform"}}
        ]
      },
      "reflection": {
        "heading": "Troubleshooting Skills Check",
        "components": [
          {"type": "checklist", "items": ["I can identify why file errors occur (FileNotFoundError, UnsupportedOperation, etc.)", "I can tell how to fix common file bugs (path, mode, with)", "I can explain a simple troubleshooting process for file I/O"]},
          {"type": "shortAnswer", "prompt": "What's your 3-step plan for fixing a FileNotFoundError?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "Which file error have you seen or made most often? How do you avoid it now?", "validation": {"type": "freeform"}}
        ]
      },
      "transition": {
        "heading": "From Troubleshooting to Evaluating",
        "components": [
          {"type": "text", "content": "You can **diagnose and fix** common file errors — FileNotFoundError, wrong mode, path issues, and missing close/with.\n\n**Why this matters:** Debugging file code is a core skill.\n\n**How you'll use this:** Next, you'll **evaluate** what makes file I/O code good — correctness, clarity, safety, and when to use which mode and with."}
        ]
      }
    },
    "s5": {
      "mindset": {
        "heading": "Choosing Good Design",
        "components": [
          {"type": "text", "content": "You're moving from fixing bugs to judging what makes file I/O code good. Focus on correctness, clarity, safety (with, no accidental overwrite), and when to use which mode."}
        ]
      },
      "recap": {
        "heading": "Troubleshooting Skills",
        "components": [
          {"type": "text", "content": "You can diagnose and fix file errors. Now you'll evaluate when file code is well-designed — clear, correct, safe, and appropriate for the task."}
        ]
      },
      "core": {
        "heading": "Evaluating File I/O Code",
        "components": [
          {"type": "text", "content": "**Evaluation criteria**\n\n**1. Correctness** — Right mode (r/w/a); file closed (with or close()); path correct. Data is read or written as intended.\n**2. Clarity** — Readable path and variable names; clear what the file is for. Comments help when the logic is non-obvious.\n**3. Safety** — Use with so the file is always closed. Avoid \"w\" when you meant to append (data loss). Confirm overwrite is intended.\n**4. Error handling** — Consider missing file (FileNotFoundError), permissions. In a later guide you'll use try/except; for now, clear code and correct path/mode matter.\n**5. Readability** — Structure (with block, then use); consistent style; newlines added explicitly so output is readable.\n**6. Purpose** — Right tool for the task: read when you need input; write when creating/overwriting; append when adding to existing content."},
          {"type": "text", "content": "**Good vs less-good examples**\n\n**Closing:**\n• Less good: f = open(\"x.txt\"); f.read(); (forget close)\n• Better: with open(\"x.txt\") as f: f.read()\n\n**Writing lines:**\n• Less good: f.write(\"a\"); f.write(\"b\") → one line\n• Better: f.write(\"a\\\\n\"); f.write(\"b\\\\n\")\n\n**Mode choice:**\n• Less good: open(\"log.txt\", \"w\") when you want to add to existing log\n• Better: open(\"log.txt\", \"a\") to append\n\n**Reading lines:**\n• For large files: for line in f: is memory-friendly\n• For small files: read() or readlines() is fine and clear"}
        ]
      },
      "guidedPractice": {
        "heading": "Evaluating File I/O Code",
        "components": [
          {"type": "text", "content": "**Activity 1:** Two snippets. Snippet A: open(\"data.txt\"); read(); no with, no close. Snippet B: with open(\"data.txt\") as f: content = f.read(). Which is better for correctness and safety? Why?"},
          {"type": "shortAnswer", "prompt": "For reading a config file that might be missing, what would you prioritize: using with, or handling the missing file? (You can mention both.)", "validation": {"type": "freeform"}},
          {"type": "multipleChoice", "question": "When is it better to use \"a\" instead of \"w\"?", "options": ["When the file is large", "When you want to add to existing content without wiping it", "When you only need to read", "When the path is absolute"], "correctIndex": 1, "feedback": {"correct": "Correct! Use \"a\" to append; \"w\" overwrites.", "incorrect": "\"a\" appends to the file; \"w\" overwrites. Use \"a\" when you want to keep existing content."}},
          {"type": "shortAnswer", "prompt": "Name one criterion (e.g. correctness, clarity, safety) that matters most to you when writing file code. Why?", "validation": {"type": "freeform"}}
        ]
      },
      "challenge": {
        "heading": "Code Review Scenario",
        "components": [
          {"type": "text", "content": "**Scenario:** You review three approaches. (A) open(\"out.txt\", \"w\"); write two lines; no close. (B) with open(\"out.txt\", \"w\") as f: f.write(\"a\\\\n\"); f.write(\"b\\\\n\"). (C) with open(\"out.txt\", \"a\") as f: f.write(\"a\\\\n\"); f.write(\"b\\\\n\"). For a script that should create a new file with exactly two lines, which is best? What's wrong with the others?"},
          {"type": "shortAnswer", "prompt": "Evaluate the three approaches above. Which would you recommend and why? Use criteria like correctness, safety, and purpose.", "validation": {"type": "freeform"}}
        ]
      },
      "reflection": {
        "heading": "Evaluation Skills Check",
        "components": [
          {"type": "checklist", "items": ["I can compare file code using correctness, clarity, safety", "I can recommend when to use r vs w vs a", "I consider purpose and readability when writing file code"]},
          {"type": "shortAnswer", "prompt": "What's your rule of thumb for when to use with for files?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "How will you use these criteria when writing your own file code from now on?", "validation": {"type": "freeform"}}
        ]
      },
      "transition": {
        "heading": "From Evaluating to Creating",
        "components": [
          {"type": "text", "content": "You can **evaluate** file I/O design — correctness, clarity, safety, and mode choice.\n\n**Why this matters:** Good file code is maintainable and less error-prone.\n\n**How you'll use this:** Next, you'll **create** your own projects — log writer, config reader, note-taker, report generator — using files. You'll bring together everything you've learned."}
        ]
      }
    },
    "s6": {
      "mindset": {
        "heading": "From Learner to Creator",
        "components": [
          {"type": "text", "content": "You're moving from judging file code to creating your own programs. Design, implement, and test small projects that read and write files to solve real tasks."}
        ]
      },
      "recap": {
        "heading": "Your Journey So Far",
        "components": [
          {"type": "text", "content": "You've completed:\n- **Remembering** → Vocabulary (open, file object, mode, read, readlines, write, close, with, path)\n- **Understanding** → How open, read, write, close, and with work\n- **Applying** → Writing file I/O code\n- **Analyzing** → Troubleshooting file errors\n- **Evaluating** → What makes file code good\n\nNow you'll **create** programs that use files to solve real tasks!"}
        ]
      },
      "core": {
        "heading": "Creating Projects with Files",
        "components": [
          {"type": "text", "content": "**Project type options**\n\n**1. Log writer** ⭐ — Append a timestamp and message to a log file each time the script runs. Use \"a\" and write(\"message\\\\n\").\n**2. Config reader** ⭐ — Read a simple .txt config (e.g. key=value per line); print or use the values. Use with and readlines(); split each line.\n**3. Simple CSV-style reader** ⭐ — Read a file with comma-separated values (one per line or whole file); split lines and commas; print or process.\n**4. Save/load state** ⭐ — Save one list or dict (e.g. as one line per item or simple format); load it back on next run. Use \"w\" to save, \"r\" to load.\n**5. Note-taking script** ⭐⭐ — Append lines typed by the user (or from input) to a notes.txt file. Use \"a\" and a loop with input() and write().\n**6. Report generator** ⭐⭐ — Build a string (e.g. report) from data (variables, list); write it to a file with \"w\". Use write() or writelines() with \\n.\n**7. Line or word counter** ⭐⭐ — Read a file; count lines (len(lines)) or split into words and count; write or print the result.\n**8. Combined read–process–write** ⭐⭐ — Read one file, process (e.g. filter or transform lines), write result to another file. Use two with blocks."},
          {"type": "text", "content": "**Templates**\n\n**Log writer (Beginner ⭐):**\nwith open(\"log.txt\", \"a\") as f:\n    f.write(\"Event: started\\\\n\")\n\n**Config reader (Beginner ⭐):**\nwith open(\"config.txt\", \"r\") as f:\n    lines = f.readlines()\nfor line in lines:\n    line = line.strip()\n    if \"=\" in line:\n        key, value = line.split(\"=\", 1)\n        print(key, value)\n\n**Save list to file (Beginner ⭐):**\nitems = [\"a\", \"b\", \"c\"]\nwith open(\"data.txt\", \"w\") as f:\n    for item in items:\n        f.write(item + \"\\\\n\")\n\n**Read list from file (Beginner ⭐):**\nwith open(\"data.txt\", \"r\") as f:\n    lines = f.readlines()\nitems = [line.strip() for line in lines]\n\n**Line counter (Intermediate ⭐⭐):**\nwith open(\"input.txt\", \"r\") as f:\n    lines = f.readlines()\ncount = len(lines)\nwith open(\"result.txt\", \"w\") as f:\n    f.write(f\"Lines: {count}\\\\n\")"},
          {"type": "text", "content": "**Success criteria**\n\n• **Log/notes:** Use \"a\"; write lines with \\n.\n• **Config/CSV:** Use with and read/readlines(); process lines.\n• **Save/load:** Write and read in a consistent format; use \"w\" to save, \"r\" to load.\n• **Report/counter:** Build content then write with \"w\"; include newlines.\n• **Combined:** Two with blocks (read file, write file); process in between."}
        ]
      },
      "guidedPractice": {
        "heading": "Plan Your Project",
        "components": [
          {"type": "shortAnswer", "prompt": "What will your program do? (e.g. log writer, config reader, note-taker, report)", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "Which file(s) will you read and which will you write? What mode (r, w, a) for each?", "validation": {"type": "freeform"}},
          {"type": "shortAnswer", "prompt": "How will you know it works? (e.g. open the file and check contents)", "validation": {"type": "freeform"}},
          {"type": "checklist", "items": ["Create a new .py file with a clear name", "Use with for all file operations", "Use the correct mode (r, w, a) for each file", "Add newlines when writing lines", "Test with a real file and verify contents", "Handle or note missing file if reading"]}
        ]
      },
      "challenge": {
        "heading": "Create and Share Your Project",
        "components": [
          {"type": "text", "content": "**Create a file-based project**\n\nChoose one (or combine):\n\n**Option 1: Log or note-taker** — Append lines to a file; use \"a\" and write with \\n.\n**Option 2: Config or CSV reader** — Read a file; process lines; print or use the data.\n**Option 3: Save/load state** — Write a list or simple data to a file; read it back on next run.\n**Option 4: Report or counter** — Generate content and write to a file; or read, count, write result.\n\n**Quality checklist:** Clear purpose; uses with; correct modes; newlines where needed; tested and verified."},
          {"type": "ordering", "instructions": "Order these steps for creating your project.", "items": ["Choose what the program will do and which files to read/write", "Write the file I/O code with with and correct modes", "Test with sample files and verify contents", "Fix bugs and add a short comment at the top"], "correctOrder": [0, 1, 2, 3]},
          {"type": "shortAnswer", "prompt": "Describe your project: what it does, which files it uses, and one design choice you made (e.g. why you used \"a\" instead of \"w\").", "validation": {"type": "freeform"}}
        ]
      },
      "reflection": {
        "heading": "Mastery Celebration",
        "components": [
          {"type": "checklist", "items": ["I created a program that reads and/or writes files", "My program has a clear purpose and uses with and correct modes", "I can explain what each file is for and how I used it", "I'm proud of what I built"]},
          {"type": "shortAnswer", "prompt": "What did you learn by creating this project? What was hardest? What would you do differently next time?", "validation": {"type": "freeform"}},
          {"type": "text", "content": "You've reached the Creating stage. You've gone from \"what is file I/O?\" to designing and building file-based programs. You can open, read, write, and close files; use with; choose modes; and troubleshoot errors. You're ready for the next step — like handling errors with exceptions for more robust file handling!"}
        ]
      },
      "transition": {
        "heading": "Congratulations on Your Journey",
        "components": [
          {"type": "text", "content": "**Journey recap:**\n\n**Stage 0 (Starting)** → What file I/O is and why it matters\n**Stage 1 (Remembering)** → Vocabulary: open, file object, mode, read, readlines, write, close, with, path\n**Stage 2 (Understanding)** → How open, read, write, close, and with work\n**Stage 3 (Applying)** → Writing file I/O code\n**Stage 4 (Analyzing)** → Troubleshooting file errors\n**Stage 5 (Evaluating)** → What makes file code good\n**Stage 6 (Creating)** → Building your own file-based projects\n\n**What's next:**\n\nYou have a solid foundation in working with files. Consider learning **errors and exceptions** next so you can handle missing files and permission errors gracefully, and write even more robust programs."}
        ]
      }
    }
  },
  "ui": {"defaultExpandedStage": "s0"}
}
