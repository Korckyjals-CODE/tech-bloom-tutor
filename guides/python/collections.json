{
  "metadata": {
    "title": "Collections",
    "subtitle": "Tuples, dictionaries, and choosing the right collection",
    "description": "Learn how to use tuples as immutable sequences, create and use dictionaries for key-value data, iterate over tuples and dictionaries, and choose the right collection type for the problem.",
    "version": "1.0.0",
    "author": "Korckyjals-CODE",
    "lastUpdated": "2026-02-03",
    "storageKeyPrefix": "collections",
    "instructorPasscode": "educafe-collections-101",
    "order": 9
  },
  "branding": {
    "brandName": "Tech Bloom Tutor",
    "theme": {
      "colorScheme": "dark",
      "primaryColor": "#4aa3ff",
      "secondaryColor": "#7bc67b"
    }
  },
  "stages": [
    {"id": "s0", "order": 0, "title": "Stage 0 · Starting", "shortTitle": "Starting", "description": "Introduction to collections"},
    {"id": "s1", "order": 1, "title": "Stage 1 · Remembering", "shortTitle": "Remembering", "description": "Vocabulary for tuples and dictionaries"},
    {"id": "s2", "order": 2, "title": "Stage 2 · Understanding", "shortTitle": "Understanding", "description": "How tuples and dictionaries work"},
    {"id": "s3", "order": 3, "title": "Stage 3 · Applying", "shortTitle": "Applying", "description": "Writing programs with tuples and dictionaries"},
    {"id": "s4", "order": 4, "title": "Stage 4 · Analyzing", "shortTitle": "Analyzing", "description": "Troubleshooting collection errors"},
    {"id": "s5", "order": 5, "title": "Stage 5 · Evaluating", "shortTitle": "Evaluating", "description": "Choosing the right collection type"},
    {"id": "s6", "order": 6, "title": "Stage 6 · Creating", "shortTitle": "Creating", "description": "Original projects with collections"}
  ],
  "sections": [
    {"id": "mindset", "displayName": "Mindset", "order": 0, "description": "Prepare mentally"},
    {"id": "recap", "displayName": "Recap", "order": 1, "description": "Connect to prior learning"},
    {"id": "core", "displayName": "Core", "order": 2, "description": "Main content"},
    {"id": "guidedPractice", "displayName": "Guided Practice", "order": 3, "description": "Practice with help"},
    {"id": "challenge", "displayName": "Challenge", "order": 4, "description": "Independent work"},
    {"id": "reflection", "displayName": "Reflection", "order": 5, "description": "Think about learning"},
    {"id": "transition", "displayName": "Transition", "order": 6, "description": "Move forward"}
  ],
  "content": {
    "s0": {
      "mindset": {"heading": "Beyond Lists: Tuples and Dictionaries", "components": [{"type": "text", "content": "You're about to learn **tuples** and **dictionaries** — two more ways to store multiple values. Lists are great for ordered sequences you can change. Tuples are for ordered data that should stay fixed. Dictionaries let you look up values by name (key) instead of position. Together with lists, these collections give you the right tool for every job."}, {"type": "text", "content": "Every expert programmer chooses the right collection for each problem. Once you master tuples and dictionaries, you'll write clearer, more efficient code and model real-world data (coordinates, student records, game scores by name) naturally."}]},
      "recap": {"heading": "Building on What You Know", "components": [{"type": "text", "content": "You already know how to:\n- Create lists with `[]` and access by index\n- Iterate over lists with `for item in list`\n- Use list methods like `append` and `pop`\n- Pass lists to functions\n\nNow you'll learn **tuples** (immutable sequences) and **dictionaries** (key–value pairs). You'll iterate over both, unpack tuples, and choose when to use lists, tuples, or dictionaries."}]},
      "core": {"heading": "What Are Collections?", "components": [{"type": "text", "content": "**Collections** are types that hold multiple values. You already know **lists** — ordered, mutable sequences. **Tuples** are ordered but **immutable** (cannot be changed after creation). **Dictionaries** store **key–value** pairs: you look up a value by its key (like a real dictionary: word → definition)."}, {"type": "text", "content": "**Real-World Examples:**\n\n**Tuples (fixed, ordered data):**\n• **Coordinates** — (x, y) or (latitude, longitude)\n• **RGB color** — (255, 128, 0)\n• **Date parts** — (2026, 2, 3)\n• **Returning multiple values** — a function returning (name, age, score)\n• **Database row** — (id, name, email) — order matters, values fixed\n\n**Dictionaries (key–value lookup):**\n• **Student record** — {\"name\": \"Ali\", \"grade\": 85}\n• **Phone book** — {\"Mom\": \"555-1234\", \"Dad\": \"555-5678\"}\n• **Game settings** — {\"volume\": 80, \"difficulty\": \"hard\"}\n• **Config** — {\"host\": \"localhost\", \"port\": 8080}\n• **Word count** — {\"the\": 5, \"and\": 3}\n• **Inventory** — {\"apple\": 10, \"banana\": 5}"}, {"type": "text", "content": "**Visual Metaphors for Collections:**\n\n**Tuple — Like a Sealed Envelope:**\nYou can read what's inside (indexing), but you cannot add, remove, or change items. The contents are fixed. Good for data that should never change.\n\n**Dictionary — Like a Real Dictionary:**\nYou look up a word (key) and get the definition (value). Keys are unique; each key maps to exactly one value. Order (in older Python) didn't matter; in Python 3.7+ insertion order is preserved."}, {"type": "text", "content": "**What Makes Tuples and Dictionaries Powerful:**\n\n**Tuples:**\n- **Immutability** — Safe to pass around; cannot be modified by mistake\n- **Unpacking** — `x, y = point` assigns both values at once\n- **Hashable** — Can be used as dictionary keys or in sets\n- **Multiple return values** — Functions can return several values cleanly\n\n**Dictionaries:**\n- **Fast lookup by name** — `student[\"grade\"]` instead of remembering index 2\n- **Meaningful keys** — \"name\" is clearer than index 0\n- **Flexible structure** — Add or change key–value pairs easily\n- **Real-world fit** — Records, configs, and mappings are everywhere"}, {"type": "text", "content": "**Connection to Prior Knowledge:**\n\n- **Lists** — Tuples use `()` and are like lists you can't change; dictionaries use `{}` and access by key.\n- **Indexing** — Tuples use `[0]`, `[1]` like lists; dictionaries use `[key]`.\n- **Loops** — `for item in tuple:` and `for key in dict:` (or `for key, value in dict.items()`).\n- **Functions** — Pass tuples and dicts as arguments; return them from functions."}, {"type": "code", "language": "python", "content": "# Tuple: immutable, parentheses\npoint = (10, 20)\nprint(point[0], point[1])  # 10 20\n\n# Unpacking\nx, y = point\nprint(x, y)  # 10 20\n\n# Dictionary: key-value pairs, curly braces\nstudent = {\"name\": \"Ali\", \"grade\": 85}\nprint(student[\"name\"])   # Ali\nprint(student[\"grade\"])  # 85", "copyable": true}]},
      "guidedPractice": {"heading": "Exploring Collections", "components": [{"type": "multipleChoice", "question": "What is the main difference between a list and a tuple?", "options": ["Tuples use curly braces", "Tuples are immutable; lists are mutable", "Lists are faster", "Dictionaries are the same as tuples"], "correctIndex": 1, "feedback": {"correct": "Correct! Tuples cannot be changed after creation; lists can be modified.", "incorrect": "The key difference is mutability: tuples are immutable, lists are mutable."}}, {"type": "shortAnswer", "prompt": "Think of three real-world things that fit key–value pairs (like a dictionary). What would the keys and values be?", "validation": {"type": "freeform"}}, {"type": "multipleChoice", "question": "When would you use a tuple instead of a list?", "options": ["When you need to append items", "When the data should not change (e.g., coordinates)", "When you need to look up by name", "When you need key-value pairs"], "correctIndex": 1, "feedback": {"correct": "Correct! Use tuples when the data is fixed and should not change.", "incorrect": "Tuples are for fixed data (coordinates, RGB, return values). Use lists when you need to add/remove."}}, {"type": "shortAnswer", "prompt": "Explain why a student record {\"name\": \"Ali\", \"grade\": 85} might be better as a dictionary than a list [\"Ali\", 85].", "validation": {"type": "freeform"}}, {"type": "multipleChoice", "question": "What does unpacking do: x, y = (10, 20)?", "options": ["Creates a new tuple", "Assigns 10 to x and 20 to y", "Swaps the values", "Causes an error"], "correctIndex": 1, "feedback": {"correct": "Correct! Unpacking assigns the first element to x and the second to y.", "incorrect": "Unpacking assigns tuple elements to variables: x=10, y=20."}}]},
      "challenge": {"heading": "Think About Collections", "components": [{"type": "multipleChoice", "question": "A program stores RGB color. Which is best?", "options": ["A list [255, 128, 0] you will change", "A tuple (255, 128, 0) that stays fixed", "A dict {\"r\": 255} with one key", "A single variable 255"], "correctIndex": 1, "feedback": {"correct": "Correct! RGB is fixed (r, g, b) — a tuple fits well.", "incorrect": "RGB is a fixed triple; a tuple (255, 128, 0) is ideal."}}, {"type": "shortAnswer", "prompt": "Describe a program you'd write that uses a dictionary. What would the keys and values represent?", "validation": {"type": "freeform"}}]},
      "reflection": {"heading": "Preparing for Learning", "components": [{"type": "checklist", "items": ["I understand what tuples and dictionaries are", "I can identify when to use each collection type", "I'm ready to learn the vocabulary and syntax"]}, {"type": "shortAnswer", "prompt": "On a scale of 1-10, how excited are you to learn tuples and dictionaries? What would make it a 10?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "What are you most curious about regarding collections? What questions do you have?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "How do you think choosing the right collection will help you write better programs?", "validation": {"type": "freeform"}}]},
      "transition": {"heading": "Ready to Learn", "components": [{"type": "text", "content": "You've learned **what tuples and dictionaries are** and **why they matter**. You understand tuples for fixed data and dictionaries for key–value lookup.\n\n**Why this matters:** Choosing the right collection makes code clearer and more efficient.\n\n**How you'll use this:** You'll learn the vocabulary — **tuple**, **immutable**, **unpacking**, **dictionary**, **key**, **value**, **.items()** — and syntax. Then you'll practice creating, accessing, and iterating over tuples and dictionaries."}]}
    },
    "s1": {
      "mindset": {"heading": "Learning the Language", "components": [{"type": "text", "content": "You're moving from the idea of collections to the specific vocabulary. Right now you're learning the terms and syntax that will let you create and use tuples and dictionaries confidently."}]},
      "recap": {"heading": "What You Remember", "components": [{"type": "text", "content": "From Stage 0, you know that tuples are immutable sequences and dictionaries store key–value pairs. Now you'll learn the precise terms: tuple, immutable, unpacking, dictionary, key, value, .keys(), .values(), .items(), and iteration over collections."}]},
      "core": {"heading": "Key Vocabulary for Collections", "components": [{"type": "text", "content": "**tuple** — An ordered, immutable sequence of values. Created with `()` or `tuple()`. Example: `(1, 2, 3)` or `(\"a\", \"b\")`. When it matters: Use for fixed data (coordinates, return values). Connection: Like a list you cannot change."}, {"type": "text", "content": "**immutable** — Cannot be changed after creation. No append, pop, or assignment to index. Example: `t = (1, 2); t[0] = 5` causes TypeError. When it matters: Tuples are immutable; lists are mutable. Connection: Immutability allows tuples to be hashable (used as dict keys)."}, {"type": "text", "content": "**unpacking** — Assigning tuple (or list) elements to variables in one step. Example: `x, y = (10, 20)` gives x=10, y=20. When it matters: Clean way to get multiple return values or coordinate parts. Connection: Number of variables must match number of elements."}, {"type": "text", "content": "**dictionary** — A collection of key–value pairs. Created with `{}` or `dict()`. Example: `{\"name\": \"Ali\", \"grade\": 85}`. When it matters: Use when you look up by name (key), not position. Connection: Keys must be unique; values can repeat."}, {"type": "text", "content": "**key** — The label used to look up a value in a dictionary. Must be hashable (e.g., str, int, tuple). Example: In `{\"age\": 20}`, \"age\" is the key. When it matters: Use meaningful keys (\"name\" not 0). Connection: Keys are unique."}, {"type": "text", "content": "**value** — The data stored for each key. Example: In `{\"age\": 20}`, 20 is the value. When it matters: Values can be any type (str, int, list, dict). Connection: Access with `dict[key]`."}, {"type": "text", "content": "**.keys()** — Returns a view of all keys. Example: `{\"a\": 1, \"b\": 2}.keys()` → dict_keys(['a', 'b']). When it matters: Iterate over keys with `for k in d.keys()` or just `for k in d`. Connection: Same as iterating over the dict directly."}, {"type": "text", "content": "**.values()** — Returns a view of all values. Example: `{\"a\": 1, \"b\": 2}.values()` → dict_values([1, 2]). When it matters: Iterate over values when you don't need keys. Connection: Order matches insertion order."}, {"type": "text", "content": "**.items()** — Returns key–value pairs as (key, value) tuples. Example: `for k, v in d.items():` loops over each pair. When it matters: Use when you need both key and value. Connection: Each item is a tuple you can unpack."}, {"type": "text", "content": "**iteration over collections** — Looping over elements. Tuples: `for item in t:`. Dict keys: `for k in d:`. Dict values: `for v in d.values()`. Dict pairs: `for k, v in d.items()`. When it matters: Choose the right loop for what you need. Connection: Same for loop; different iteration targets."}]},
      "guidedPractice": {"heading": "Vocabulary Practice", "components": [{"type": "matching", "leftColumn": ["tuple", "immutable", "unpacking", "dictionary", "key", "value", ".keys()", ".values()", ".items()"], "rightColumn": [{"definition": "Ordered, immutable sequence", "matchesWith": "tuple"}, {"definition": "Cannot be changed after creation", "matchesWith": "immutable"}, {"definition": "Assign tuple elements to variables in one step", "matchesWith": "unpacking"}, {"definition": "Collection of key-value pairs", "matchesWith": "dictionary"}, {"definition": "Label used to look up a value", "matchesWith": "key"}, {"definition": "Data stored for each key", "matchesWith": "value"}, {"definition": "Returns all keys in a dict", "matchesWith": ".keys()"}, {"definition": "Returns all values in a dict", "matchesWith": ".values()"}, {"definition": "Returns (key, value) pairs for iteration", "matchesWith": ".items()"}]}, {"type": "multipleChoice", "question": "In the tuple (10, 20, 30), what is the index of 20?", "options": ["0", "1", "2", "20"], "correctIndex": 1, "feedback": {"correct": "Correct! Indices start at 0, so 10 is 0, 20 is 1, 30 is 2.", "incorrect": "Tuples use 0-based indexing like lists. 20 is at index 1."}}, {"type": "multipleChoice", "question": "What does student.get(\"grade\", 0) do?", "options": ["Returns student[\"grade\"] or 0 if key missing", "Adds grade 0", "Raises KeyError", "Returns all keys"], "correctIndex": 0, "feedback": {"correct": "Correct! .get(key, default) returns the value or default if key is missing.", "incorrect": ".get(key, default) safely returns the value or the default if the key doesn't exist."}}]},
      "challenge": {"heading": "Vocabulary Application", "components": [{"type": "text", "content": "**Creative Visualization Task:**\n\nDraw or describe a dictionary like {\"name\": \"Ali\", \"grade\": 85}. Label each key, each value, and show how you would access \"grade\"."}, {"type": "shortAnswer", "prompt": "Explain the difference between a tuple and a list. When would you use each?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "What does 'immutable' mean for a tuple? Give one reason why immutability can be useful.", "validation": {"type": "freeform"}}]},
      "reflection": {"heading": "Vocabulary Check", "components": [{"type": "checklist", "items": ["I can define tuple, immutable, unpacking, dictionary, key, value", "I can recall .keys(), .values(), and .items()", "I understand how these terms work together"]}, {"type": "shortAnswer", "prompt": "Which term was easiest for you? Which needs more review?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "Can you recall: how do you iterate over both keys and values in a dictionary?", "validation": {"type": "freeform"}}]},
      "transition": {"heading": "From Terms to Understanding", "components": [{"type": "text", "content": "You've learned the vocabulary: **tuple**, **immutable**, **unpacking**, **dictionary**, **key**, **value**, **.keys()**, **.values()**, **.items()**.\n\n**Why this matters:** Knowing the terms is the first step. Now you'll understand **how** tuples and dictionaries work — indexing, unpacking, dict access, and iteration.\n\n**How you'll use this:** Next, you'll learn the step-by-step process: how tuple indexing works, how dict[key] and .get() differ, and how for loops over collections behave."}]}
    },
    "s2": {
      "mindset": {"heading": "Understanding the Process", "components": [{"type": "text", "content": "You're moving from knowing the terms to understanding **how** tuples and dictionaries actually work: how tuple indexing and unpacking behave, how dict access and .get() differ, and how iteration over each collection produces different results."}]},
      "recap": {"heading": "What You Know", "components": [{"type": "text", "content": "You know the vocabulary: tuple, immutable, unpacking, dictionary, key, value, .keys(), .values(), .items(). Now you'll see how Python uses these when you index, unpack, access, or iterate."}]},
      "core": {"heading": "How Tuples and Dictionaries Work", "components": [{"type": "text", "content": "**Step-by-Step: Tuple Indexing**\n\n**Step 1:** Tuples use 0-based indexing like lists. t[0] is first, t[1] is second, t[-1] is last.\n**Step 2:** t[i] returns the element at position i. Valid indices: 0 to len(t)-1 (or negative).\n**Step 3:** Index out of range causes IndexError. Slicing works: t[1:3] returns a new tuple.\n**Step 4:** You cannot assign: t[0] = 5 causes TypeError (immutable)."}, {"type": "text", "content": "**Step-by-Step: Tuple Unpacking**\n\n**Step 1:** Python evaluates the right side (tuple or other iterable).\n**Step 2:** It assigns element 0 to the first variable, element 1 to the second, etc.\n**Step 3:** Number of variables must match number of elements, or use * to capture rest: a, *b = (1, 2, 3) gives a=1, b=[2, 3].\n**Step 4:** Unpacking works for lists and other iterables too."}, {"type": "text", "content": "**Step-by-Step: Dictionary Access**\n\n**Step 1:** d[key] returns the value for that key. If key is missing, KeyError.\n**Step 2:** d.get(key, default) returns the value or default if key is missing. No KeyError.\n**Step 3:** d[key] = value adds or updates the key–value pair. Dictionaries are mutable.\n**Step 4:** Keys must be hashable (str, int, tuple, etc.); values can be any type."}, {"type": "text", "content": "**Step-by-Step: Iteration Over Collections**\n\n**Tuple:** for item in t: — item takes each element in order.\n**Dict keys:** for k in d: (or for k in d.keys():) — k takes each key.\n**Dict values:** for v in d.values(): — v takes each value.\n**Dict pairs:** for k, v in d.items(): — k and v take each key–value pair; each pair is a tuple."}, {"type": "text", "content": "**Key Idea: Same Syntax, Different Behavior**\n\n- Tuples: Index and slice like lists; cannot mutate. Use for fixed data.\n- Dictionaries: Access by key, not index. Use when name matters more than position.\n- Both: Iterable; can use in for loops. Choose based on how you look up data."}, {"type": "code", "language": "python", "content": "# Tuple: index, unpack, slice\npoint = (10, 20)\nprint(point[0], point[-1])  # 10 20\nx, y = point\nprint(x, y)  # 10 20\n\n# Dict: access, .get, iterate\nstudent = {\"name\": \"Ali\", \"grade\": 85}\nprint(student[\"name\"])       # Ali\nprint(student.get(\"age\", 0)) # 0 (key missing)\nfor k, v in student.items():\n    print(k, v)", "copyable": false}]},
      "guidedPractice": {"heading": "Understanding the Flow", "components": [{"type": "shortAnswer", "prompt": "What happens step-by-step when Python runs 'for k, v in {\"a\": 1, \"b\": 2}.items(): print(k, v)'? Describe the process.", "validation": {"type": "freeform"}}, {"type": "multipleChoice", "question": "After x, y = (5, 10), what are x and y?", "options": ["x=5, y=10", "x=(5,10), y=None", "Error", "x=10, y=5"], "correctIndex": 0, "feedback": {"correct": "Correct! Unpacking assigns first to x, second to y.", "incorrect": "Unpacking assigns tuple elements left to right: x=5, y=10."}}, {"type": "multipleChoice", "question": "What happens if you do d[\"missing\"] when \"missing\" is not in d?", "options": ["Returns None", "Returns 0", "KeyError", "Creates the key"], "correctIndex": 2, "feedback": {"correct": "Correct! d[key] raises KeyError if key is missing. Use .get() for safe access.", "incorrect": "d[key] raises KeyError when the key doesn't exist. Use d.get(key, default) for safe access."}}, {"type": "shortAnswer", "prompt": "Why does t[0] = 5 fail for a tuple t but work for a list? What error do you get?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "Explain the difference between d[\"key\"] and d.get(\"key\", 0). When would you use each?", "validation": {"type": "freeform"}}]},
      "challenge": {"heading": "Create a Flow Diagram", "components": [{"type": "text", "content": "**Creative Diagram Task:**\n\nCreate a flowchart or diagram showing how 'for k, v in d.items():' works. Include: (1) get first (key, value) pair, (2) assign to k and v, (3) run body, (4) get next pair or exit."}, {"type": "shortAnswer", "prompt": "Describe your diagram. How does it show when the loop runs and when it stops?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "What is the difference between iterating over d and iterating over d.items()? What does each give you?", "validation": {"type": "freeform"}}]},
      "reflection": {"heading": "Understanding Check", "components": [{"type": "checklist", "items": ["I can explain how tuple indexing and unpacking work", "I can describe how dict access and .get() differ", "I understand how iteration over tuples and dicts works"]}, {"type": "shortAnswer", "prompt": "What was the most surprising thing about how collections work?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "How does understanding .get() vs [key] help you avoid errors?", "validation": {"type": "freeform"}}]},
      "transition": {"heading": "From Understanding to Doing", "components": [{"type": "text", "content": "You understand **how** tuples and dictionaries work — indexing, unpacking, dict access, .get(), and iteration.\n\n**Why this matters:** Understanding the process helps you write correct collection code and fix bugs.\n\n**How you'll use this:** Next, you'll **apply** this by writing your own programs: creating tuples and dicts, unpacking, iterating with .items(), and passing collections to functions."}]}
    },
    "s3": {
      "mindset": {"heading": "Time to Code", "components": [{"type": "text", "content": "You're moving from understanding to **doing**. Now you'll write your own tuple and dictionary code. Focus on correct syntax: parentheses for tuples, curly braces for dicts, and .items() for iteration. Mistakes are normal — that's how you learn!"}]},
      "recap": {"heading": "Before You Start", "components": [{"type": "text", "content": "You understand how tuples and dictionaries work. Now let's write them! Make sure you can answer: How do you create a tuple? How do you access a dict value? How do you iterate over key–value pairs?"}]},
      "core": {"heading": "Writing Collection Code: Step-by-Step", "components": [{"type": "text", "content": "**Preparation Checklist**\n\n✓ Python installed; text editor and terminal ready\n✓ Folder for Python files\n✓ You know lists, loops, and functions\n✓ You understand tuple and dict vocabulary\n\nOnce you've checked these off, you're ready to write collection code!"}, {"type": "text", "content": "**Step-by-Step: Your First Tuple**\n\n**Step 1:** Create a new file, e.g. collections_demo.py\n**Step 2:** Create a tuple: point = (10, 20)\n**Step 3:** Access: print(point[0], point[1])\n**Step 4:** Unpack: x, y = point; print(x, y)\n**Step 5:** Single-element tuple needs comma: t = (1,) not (1)\n\n**Step-by-Step: Your First Dictionary**\n\n**Step 1:** Create: student = {\"name\": \"Ali\", \"grade\": 85}\n**Step 2:** Access: print(student[\"name\"])\n**Step 3:** Safe access: print(student.get(\"age\", 0))\n**Step 4:** Add/update: student[\"age\"] = 18\n**Step 5:** Iterate: for k, v in student.items(): print(k, v)"}, {"type": "text", "content": "**Common Pitfalls and How to Avoid Them**\n\n1. **Single-element tuple** — (1) is just 1; use (1,) for a tuple. Fix: Add trailing comma.\n2. **KeyError** — d[key] when key missing. Fix: Use d.get(key, default) or check 'key in d'.\n3. **Tuple assignment** — t[0] = 5 fails (immutable). Fix: Create new tuple or use list.\n4. **Unpacking mismatch** — a, b = (1, 2, 3) raises ValueError. Fix: Match count or use *rest.\n5. **Mutable key** — d[[1,2]] = 0 fails; lists aren't hashable. Fix: Use tuple or str as key.\n6. **Typo in key** — student[\"nam\"] returns KeyError. Fix: Check spelling; use .get() for optional keys.\n7. **Confusing () and {}** — Tuples use (); dicts use {}. Fix: Remember: () tuple, {} dict.\n8. **Forgetting .items()** — for k in d gives keys only. Fix: Use for k, v in d.items() when you need both.\n9. **Empty dict** — {} not {:}. Fix: {} is correct for empty dict.\n10. **Return multiple values** — return a, b returns tuple (a, b). Fix: Caller can x, y = func()."}, {"type": "text", "content": "**Verification Steps**\n\n1. **Tuple** — Print tuple, index, unpack; confirm values.\n2. **Dict** — Print dict, access by key, use .get(); confirm.\n3. **Loop** — for k, v in d.items(): print; confirm all pairs.\n4. **Function** — Pass tuple/dict; return tuple/dict; check result."}, {"type": "code", "language": "python", "content": "# Tuple and unpacking\npoint = (10, 20)\nx, y = point\nprint(x, y)\n\n# Dictionary and iteration\nstudent = {\"name\": \"Ali\", \"grade\": 85}\nstudent[\"age\"] = 18\nfor k, v in student.items():\n    print(k, v)", "copyable": true}, {"type": "code", "language": "python", "content": "# Function returning tuple\ndef min_max(nums):\n    return min(nums), max(nums)\n\nlow, high = min_max([3, 1, 4, 1, 5])\nprint(low, high)  # 1 5", "copyable": true}]},
      "guidedPractice": {"heading": "Practice Writing Collection Code", "components": [{"type": "checklist", "items": ["I have Python and a text editor ready", "I understand tuple and dict syntax", "I know how to use .get() and .items()", "I'm ready to write my first collection program"]}, {"type": "text", "content": "**Activity: Student Record**\n\n1. Create collections_demo.py\n2. Create a dict: student = {\"name\": \"YourName\", \"grade\": 85}\n3. Add a key \"age\" with value 18\n4. Print each key-value pair using .items()\n5. Use .get(\"phone\", \"N/A\") and print the result"}, {"type": "shortAnswer", "prompt": "What output do you get for .get(\"phone\", \"N/A\")? Why?", "validation": {"type": "freeform"}}, {"type": "multipleChoice", "question": "What does (1,) create?", "options": ["The integer 1", "A tuple with one element", "A list", "Syntax error"], "correctIndex": 1, "feedback": {"correct": "Correct! (1,) is a single-element tuple. The comma is required.", "incorrect": "The comma makes (1,) a tuple with one element. (1) alone is just the integer 1."}}, {"type": "multipleChoice", "question": "How do you safely get a value that might not exist?", "options": ["d[key]", "d.get(key, default)", "d.value(key)", "d(key)"], "correctIndex": 1, "feedback": {"correct": "Correct! .get(key, default) returns the value or default if key is missing.", "incorrect": "Use d.get(key, default) for safe access when the key might not exist."}}]},
      "challenge": {"heading": "Create a Collection Program", "components": [{"type": "text", "content": "**Create a Proof-of-Work Program**\n\nCreate collections_tools.py that:\n\n1. Creates a tuple of 2–3 values (e.g., coordinates or RGB) and unpacks it\n2. Creates a dictionary with at least 3 key-value pairs (e.g., student or config)\n3. Uses .get() for an optional key\n4. Iterates over the dict with .items() and prints each pair\n5. Defines a function that takes a dict and returns one value (e.g., count of keys, or a specific value)\n6. Defines a function that returns a tuple (e.g., min and max of a list), and unpacks the result\n\n**Requirements:** File named collections_tools.py; no errors when run; paste of code and output."}, {"type": "shortAnswer", "prompt": "What was the most challenging part of writing your collection program? How did you solve it?", "validation": {"type": "freeform"}}]},
      "reflection": {"heading": "Application Check", "components": [{"type": "checklist", "items": ["I can create tuples and dictionaries", "I can unpack tuples and use .get()", "I can iterate with .items()", "I can write functions that take/return tuples and dicts", "I can test my collection programs"]}, {"type": "shortAnswer", "prompt": "What was the easiest part of writing collection code? What was the most confusing?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "How confident do you feel using tuples and dictionaries now? What would help you feel more confident?", "validation": {"type": "freeform"}}]},
      "transition": {"heading": "From Writing to Troubleshooting", "components": [{"type": "text", "content": "You can now **write collection code** — create tuples and dicts, unpack, iterate with .items(), and use functions. You're ready to **analyze and troubleshoot** when something goes wrong: KeyError, tuple mutation, unpacking errors, and other common collection errors."}]}
    },
    "s4": {
      "mindset": {"heading": "Becoming a Troubleshooter", "components": [{"type": "text", "content": "You're moving from writing correct collection code to understanding what goes wrong. Every KeyError, TypeError, or unpacking failure is a clue. Check keys, immutability, and loop targets."}]},
      "recap": {"heading": "What Works", "components": [{"type": "text", "content": "You know how to write tuple and dictionary code that works. Now we'll look at what happens when it doesn't — and how to fix it."}]},
      "core": {"heading": "Troubleshooting Collection Errors", "components": [{"type": "text", "content": "**Error Analysis Table: Common Collection Errors**\n\n**Error 1: KeyError — key not in dictionary**\n**Symptom:** KeyError: 'keyname'\n**Possible Cause:** Accessing d[key] when key doesn't exist\n**How to Verify:** Print d.keys() or use 'key in d'\n**How to Fix:** Use d.get(key, default) or if key in d: before access\n\n**Error 2: TypeError — 'tuple' object does not support item assignment**\n**Symptom:** TypeError when doing t[0] = x\n**Possible Cause:** Tuples are immutable\n**How to Verify:** Check if variable is tuple (type(t) is tuple)\n**How to Fix:** Use list if you need to change; or create new tuple\n\n**Error 3: ValueError — not enough/too many values to unpack**\n**Symptom:** ValueError when a, b = (1,) or a, b = (1, 2, 3)\n**Possible Cause:** Variable count doesn't match element count\n**How to Verify:** Count elements and variables\n**How to Fix:** Match counts or use *rest: a, *b = (1, 2, 3)\n\n**Error 4: TypeError — unhashable type: 'list'**\n**Symptom:** Using list as dict key\n**Possible Cause:** Dict keys must be hashable; lists are not\n**How to Verify:** Check what you use as key\n**How to Fix:** Use tuple or str; convert list to tuple if needed\n\n**Error 5: Single-element tuple confusion**\n**Symptom:** type((1)) is int, not tuple\n**Possible Cause:** (1) is just 1; comma required for tuple\n**How to Verify:** type((1,)) is tuple\n**How to Fix:** Use (1,) for single-element tuple\n\n**Error 6: Iterating over dict gives keys only**\n**Symptom:** for x in d: gives keys, not values\n**Possible Cause:** Default iteration is over keys\n**How to Verify:** Check what you need (keys, values, or both)\n**How to Fix:** Use d.values() or d.items() as needed\n\n**Error 7: Typo in key**\n**Symptom:** KeyError for similar key (e.g., \"nam\" vs \"name\")\n**Possible Cause:** Misspelled key\n**How to Verify:** Print d and check key spelling\n**How to Fix:** Fix spelling or use .get() for optional keys\n\n**Error 8: Modifying dict while iterating**\n**Symptom:** Unexpected behavior or RuntimeError\n**Possible Cause:** Adding/removing keys in for k in d\n**How to Verify:** Look for dict modification inside loop\n**How to Fix:** Iterate over list(d) or build new dict"}, {"type": "text", "content": "**Systematic Troubleshooting Steps**\n\n**Step 1:** Identify the symptom — KeyError, TypeError, ValueError?\n**Step 2:** Find the line — which access, assignment, or loop?\n**Step 3:** For KeyError: is the key in the dict? Use .get() or 'in'.\n**Step 4:** For tuple: are you trying to mutate? Tuples are immutable.\n**Step 5:** For unpacking: do variable and element counts match?\n**Step 6:** Print the collection at key points to verify state."}, {"type": "code", "language": "python", "content": "# Common errors and fixes\n\n# ERROR 1: KeyError\n# d = {\"a\": 1}; print(d[\"b\"])  # KeyError\n# FIX:\nprint({\"a\": 1}.get(\"b\", 0))  # 0\n\n# ERROR 2: tuple mutation\n# t = (1, 2); t[0] = 5  # TypeError\n# FIX: use list or new tuple\nt = (5, 2)\n\n# ERROR 3: unpacking\n# a, b = (1,)  # ValueError\n# FIX: match count\na, = (1,)", "copyable": false}]},
      "guidedPractice": {"heading": "Error Diagnosis Practice", "components": [{"type": "text", "content": "**Activity 1: Find the bug**\n\n```python\nd = {\"name\": \"Ali\"}\nprint(d[\"age\"])\n```\n\n**What's wrong?**"}, {"type": "shortAnswer", "prompt": "What error does the code above cause? How do you fix it?", "validation": {"type": "contains", "acceptedAnswers": ["KeyError", "Key", "get", "age", "missing"]}}, {"type": "multipleChoice", "question": "What error does t = (1, 2); t[0] = 5 cause?", "options": ["KeyError", "TypeError (immutable)", "ValueError", "No error"], "correctIndex": 1, "feedback": {"correct": "Correct! Tuples are immutable; you cannot assign to an index.", "incorrect": "Tuples don't support item assignment — TypeError."}}, {"type": "shortAnswer", "prompt": "Write a 3-step process you would use to debug a KeyError.", "validation": {"type": "freeform"}}]},
      "challenge": {"heading": "Create a Troubleshooting Flowchart", "components": [{"type": "text", "content": "**Creative Task:**\n\nCreate a small flowchart or list for debugging KeyError. Include: (1) Check if key exists, (2) Verify key spelling, (3) Use .get() or 'in' for safe access."}, {"type": "shortAnswer", "prompt": "Describe your debugging process. What do you check first when you get a KeyError?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "A program gets ValueError when unpacking. What two things would you check?", "validation": {"type": "freeform"}}]},
      "reflection": {"heading": "Troubleshooting Skills Check", "components": [{"type": "checklist", "items": ["I can identify why collection errors occur (KeyError, TypeError, ValueError)", "I can tell how to fix common collection bugs", "I can explain a simple troubleshooting process for collections"]}, {"type": "shortAnswer", "prompt": "What's your 3-step plan for fixing a KeyError?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "Which collection error have you seen or made most often? How do you avoid it now?", "validation": {"type": "freeform"}}]},
      "transition": {"heading": "From Troubleshooting to Evaluating", "components": [{"type": "text", "content": "You can **diagnose and fix** common collection errors — KeyError, tuple mutation, unpacking mismatch, and unhashable keys.\n\n**Why this matters:** Debugging collection code is a core skill.\n\n**How you'll use this:** Next, you'll **evaluate** when to use lists, tuples, or dictionaries — choosing the right collection for each problem."}]}
    },
    "s5": {
      "mindset": {"heading": "Choosing Good Design", "components": [{"type": "text", "content": "You're moving from fixing bugs to choosing the best collection. Focus on when to use a list vs tuple vs dictionary, and how to keep collection code clear and readable."}]},
      "recap": {"heading": "Troubleshooting Skills", "components": [{"type": "text", "content": "You can diagnose and fix collection errors. Now you'll judge when each collection type is the right choice — lists, tuples, or dictionaries."}]},
      "core": {"heading": "Evaluating Collection Choice", "components": [{"type": "text", "content": "**Evaluation Criteria: Choosing the Right Collection**\n\n**1. List** — Use when:\n- Order matters and you need to change the sequence (append, remove, sort)\n- You access by position (index 0, 1, 2)\n- Examples: shopping list, grades in order, menu items\n\n**2. Tuple** — Use when:\n- Data is fixed and should not change (coordinates, RGB, return values)\n- You want it hashable (as dict key or in set)\n- Returning multiple values from a function\n- Examples: (x, y), (r, g, b), (min_val, max_val)\n\n**3. Dictionary** — Use when:\n- You look up by name (key), not position\n- Keys are meaningful labels (\"name\", \"grade\", \"id\")\n- Data is a record or mapping\n- Examples: student record, config, phone book, word count"}, {"type": "text", "content": "**Good vs. Less Good Examples**\n\n**Coordinates:**\n- Less good: coords = [10, 20] (mutable; might change by mistake)\n- Better: coords = (10, 20) (immutable; clearly fixed)\n\n**Student record:**\n- Less clear: student = [\"Ali\", 85, 18] (what is index 1?)\n- Clearer: student = {\"name\": \"Ali\", \"grade\": 85, \"age\": 18}\n\n**Returning two values:**\n- Awkward: return [min_val, max_val] (list implies mutable)\n- Clean: return min_val, max_val (tuple; natural unpacking)"}]},
      "guidedPractice": {"heading": "Evaluating Collection Choice", "components": [{"type": "text", "content": "**Activity 1: Choose the structure**\n\n**Scenario A:** Store (latitude, longitude) for a location.\n**Scenario B:** Store student name, grade, and email.\n\nWhich collection for each? Why?"}, {"type": "shortAnswer", "prompt": "For Scenario A and B, which collection would you use? Give a one-sentence reason for each.", "validation": {"type": "freeform"}}, {"type": "multipleChoice", "question": "When should you use a dictionary instead of a list?", "options": ["When order matters most", "When you look up by meaningful key (e.g., name)", "When you need to append often", "When data must be immutable"], "correctIndex": 1, "feedback": {"correct": "Correct! Use a dict when you look up by key (name, id, etc.).", "incorrect": "Dictionaries are for key-value lookup. Use when the key (name, id) matters more than position."}}, {"type": "shortAnswer", "prompt": "Name one situation where a tuple is better than a list. Explain briefly.", "validation": {"type": "freeform"}}]},
      "challenge": {"heading": "Code Review Scenario", "components": [{"type": "text", "content": "**Review this code:**\n\n```python\ndef get_user():\n    return [\"Ali\", 25, \"ali@email.com\"]\nname, age, email = get_user()\n```\n\n**Questions:** Does it work? Would a tuple or dict be clearer? Why?"}, {"type": "shortAnswer", "prompt": "Evaluate the code above. Would you use a list, tuple, or dict for the return value? Explain your choice.", "validation": {"type": "freeform"}}]},
      "reflection": {"heading": "Evaluation Skills Check", "components": [{"type": "checklist", "items": ["I can choose when to use list vs tuple vs dictionary", "I can tell when collection code is clear vs confusing", "I consider appropriateness when writing collection code"]}, {"type": "shortAnswer", "prompt": "What's your rule of thumb for when to use a dictionary?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "How will you use these criteria when writing your own collection code from now on?", "validation": {"type": "freeform"}}]},
      "transition": {"heading": "From Evaluating to Creating", "components": [{"type": "text", "content": "You can **evaluate** collection design and choose when each type is appropriate. You think about clarity, correctness, and fit for the problem.\n\n**Why this matters:** Good collection choice makes programs easier to read and maintain.\n\n**How you'll use this:** Next, you'll **create** your own projects — student records, config managers, coordinate tools — using tuples and dictionaries. You'll bring together everything you've learned."}]}
    },
    "s6": {
      "mindset": {"heading": "From Learner to Creator", "components": [{"type": "text", "content": "You're moving from judging collection design to creating your own programs. Design, implement, and test small projects that use tuples and dictionaries to solve real tasks."}]},
      "recap": {"heading": "Your Journey So Far", "components": [{"type": "text", "content": "You've completed:\n- **Remembering** → Vocabulary (tuple, immutable, unpacking, dict, key, value, .items())\n- **Understanding** → How indexing, unpacking, and dict access work\n- **Applying** → Writing collection code and functions\n- **Analyzing** → Troubleshooting KeyError, tuple mutation, unpacking\n- **Evaluating** → When to use list vs tuple vs dict\n\nNow you'll **create** programs that use tuples and dictionaries to solve real tasks!"}]},
      "core": {"heading": "Creating Projects with Collections", "components": [{"type": "text", "content": "**Project Type Options**\n\n**1. Student/Contact Record** ⭐\nDict with name, grade, email; print each key-value; use .get() for optional phone. Add a function that takes the dict and returns one value (e.g., grade or formatted string).\n\n**2. Coordinate Helper** ⭐\nTuple (x, y); unpack and print; function that takes two points (tuples) and returns distance or midpoint as tuple.\n\n**3. Config Manager** ⭐\nDict of settings (host, port, debug); read values; optional: update one and print. Use .get() for missing keys.\n\n**4. Word Counter** ⭐⭐\nBuild dict {word: count} from a list of words (loop, increment count). Print each word and its count using .items().\n\n**5. Min/Max Return** ⭐⭐\nFunction that takes a list of numbers and returns (min, max) as tuple. Call and unpack: low, high = min_max(nums).\n\n**6. Simple Database of Records** ⭐⭐\nList of dicts (e.g., students); loop over list, access each dict by key; find one by name.\n\n**7. RGB/Color Helper** ⭐⭐\nTuple (r, g, b); function that takes color tuple and returns brightness or inverted tuple.\n\n**8. Phone Book** ⭐⭐\nDict name → phone; add, lookup, list all. Use .get() for lookup (return \"Not found\" if missing)."}, {"type": "text", "content": "**Templates and Examples**\n\n**Template 1: Student record (Beginner ⭐)**\n```python\nstudent = {\"name\": \"Ali\", \"grade\": 85, \"email\": \"ali@school.com\"}\nfor k, v in student.items():\n    print(k, v)\nprint(\"Phone:\", student.get(\"phone\", \"N/A\"))\n```\n\n**Template 2: Min/max tuple return (Beginner ⭐)**\n```python\ndef min_max(nums):\n    return min(nums), max(nums)\nlow, high = min_max([3, 1, 4, 1, 5])\nprint(low, high)\n```\n\n**Template 3: Word counter (Intermediate ⭐⭐)**\n```python\nwords = [\"the\", \"cat\", \"the\", \"dog\"]\ncounts = {}\nfor w in words:\n    counts[w] = counts.get(w, 0) + 1\nfor w, c in counts.items():\n    print(w, c)\n```\n\n**Template 4: Coordinate midpoint (Intermediate ⭐⭐)**\n```python\ndef midpoint(p1, p2):\n    return ((p1[0]+p2[0])/2, (p1[1]+p2[1])/2)\na, b = (0, 0), (4, 4)\nx, y = midpoint(a, b)\nprint(x, y)\n```"}, {"type": "text", "content": "**Success Criteria**\n\n- **Student/Config:** Dict with 3+ keys; iterate with .items(); use .get() for optional key.\n- **Coordinate:** Tuple creation and unpacking; function returning tuple.\n- **Word counter:** Dict built in loop; .items() iteration.\n- **Min/max:** Function returns tuple; caller unpacks.\n- **Phone book:** Add, lookup with .get(), list all."}]},
      "guidedPractice": {"heading": "Plan Your Project", "components": [{"type": "shortAnswer", "prompt": "What will your program do? (e.g., student record, config, word counter, coordinates)", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "Will you use tuples, dictionaries, or both? What will they hold?", "validation": {"type": "freeform"}}, {"type": "shortAnswer", "prompt": "How will you know it works? (e.g., test with known data)", "validation": {"type": "freeform"}}, {"type": "checklist", "items": ["Create a new .py file with a clear name", "Create at least one tuple and/or one dict", "Use unpacking or .items() at least once", "Use .get() for at least one optional key", "Use at least one function that takes or returns tuple/dict", "Test with sample data", "Fix any bugs"]}]},
      "challenge": {"heading": "Create and Share Your Project", "components": [{"type": "text", "content": "**Create a Collection-Based Project**\n\nChoose one (or combine ideas):\n\n**Option 1: Student/contact record** — Dict; iterate with .items(); .get() for optional field; function that processes the dict.\n**Option 2: Coordinate/color helper** — Tuples; unpacking; function returning tuple.\n**Option 3: Word counter or phone book** — Dict built/updated in loop; .items() to display.\n**Option 4: Min/max or similar** — Function returns tuple; caller unpacks.\n\n**Quality checklist:**\n- Clear purpose; at least one tuple or dict used correctly\n- Unpacking or .items() used\n- .get() for safe access where appropriate\n- At least one function taking or returning tuple/dict\n- Tested with normal inputs\n- Code is readable"}, {"type": "ordering", "instructions": "Order these steps for creating your project.", "items": ["Choose what the program will do", "Decide what tuples/dicts will hold", "Write the collection code and functions", "Test with sample data", "Fix bugs and improve clarity", "Add a short comment at the top"], "correctOrder": [0, 1, 2, 3, 4, 5]}, {"type": "shortAnswer", "prompt": "Describe your project: what it does, what collections it uses, and one design choice you made.", "validation": {"type": "freeform"}}]},
      "reflection": {"heading": "Mastery Celebration", "components": [{"type": "checklist", "items": ["I created a program that uses tuples and/or dictionaries", "My program has a clear purpose and uses .items() or unpacking", "I can explain what each collection holds and how I used it", "I'm proud of what I built"]}, {"type": "shortAnswer", "prompt": "What did you learn by creating this project? What was hardest? What would you do differently next time?", "validation": {"type": "freeform"}}, {"type": "text", "content": "You've reached the Creating stage. You've gone from \"what are tuples and dictionaries?\" to designing and building collection-based programs. You can create tuples and dicts, unpack, iterate with .items(), and choose the right collection for each problem. You're ready for more advanced Python topics!"}]},
      "transition": {"heading": "Congratulations on Your Journey", "components": [{"type": "text", "content": "**Journey Recap:**\n\n**Stage 0 (Starting)** → What tuples and dictionaries are and why they matter\n**Stage 1 (Remembering)** → Vocabulary: tuple, immutable, unpacking, dict, key, value, .items()\n**Stage 2 (Understanding)** → How indexing, unpacking, and dict access work\n**Stage 3 (Applying)** → Writing collection code and functions\n**Stage 4 (Analyzing)** → Troubleshooting KeyError, tuple mutation, unpacking\n**Stage 5 (Evaluating)** → When to use list vs tuple vs dict\n**Stage 6 (Creating)** → Building your own collection-based projects\n\n**What's Next:**\n\nYou now have a solid foundation in Python collections — lists, tuples, and dictionaries. You can choose the right structure for each problem and iterate over them confidently. Consider exploring file I/O, modules, or more advanced data structures next."}]}
    }
  },
  "ui": {"defaultExpandedStage": "s0"}
}
