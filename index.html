<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Installing Python on Windows â€” Interactive Student Guide</title>
  <style>
    :root {
      --bg: #0b0e12;
      --panel: #11161d;
      --muted: #9fb0c3;
      --text: #e6eef6;
      --accent: #4aa3ff;
      --accent-2: #7bc67b;
      --warn: #ffb86b;
      --danger: #ff6b6b;
      --border: #1e2630;
      --good: #20c997;
    }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    .app { display:flex; min-height: 100dvh; }
    .sidebar { width: 320px; background: var(--panel); border-right: 1px solid var(--border); padding: 16px; overflow:auto; position: sticky; top:0; height: 100dvh; }
    .brand { font-weight: 700; font-size: 20px; margin-bottom: 8px; }
    .student-box { display:flex; gap:8px; margin: 8px 0 16px; }
    input[type=text] { background:#0c1219; border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:8px; flex:1; }
    button, .btn { background: var(--accent); color: white; border: none; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    button.secondary { background: #213346; color: var(--text); }
    button.link { background: transparent; color: var(--accent); padding:0; }
    .muted { color: var(--muted); font-size: 12px; }
    .stage-list { margin: 12px 0; display:flex; flex-direction: column; gap: 6px; }
    .stage { border:1px solid var(--border); border-radius: 10px; overflow:hidden; }
    .stage > summary { list-style:none; cursor:pointer; padding:10px 12px; background:#0d141b; display:flex; align-items:center; justify-content: space-between; }
    .badge { font-size: 11px; background:#17202a; padding: 2px 8px; border-radius: 999px; border:1px solid var(--border); }
    .section-links { padding: 10px 12px; border-top:1px solid var(--border); display:grid; grid-template-columns: 1fr 1fr; gap:6px; }
    .section-links a { text-decoration:none; color: var(--text); background:#0c1219; border:1px solid var(--border); padding:8px; border-radius:8px; font-size: 13px; }
    .main { flex:1; padding: 20px; overflow:auto; }
    .topbar { position: sticky; top:0; backdrop-filter: blur(8px); background: rgba(11,14,18,0.7); border-bottom:1px solid var(--border); padding: 10px 0 12px; z-index: 5; }
    .breadcrumbs { font-size: 12px; color: var(--muted); display:flex; gap:8px; align-items:center; }
    .breadcrumbs .stage-chip { background:#141b24; border:1px solid var(--border); padding:2px 8px; border-radius:999px; color: var(--text); }
    .progress-wrap { margin-top:8px; }
    .meter { height: 10px; width: 100%; background:#0c1219; border-radius:999px; border:1px solid var(--border); overflow:hidden; }
    .meter > div { height:100%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); width:0%; transition: width .3s ease; }
    .content { max-width: 1000px; margin: 0 auto; padding-top: 16px; }
    h1 { font-size: 28px; margin: 8px 0 6px; }
    h2 { font-size: 22px; margin: 20px 0 8px; }
    p, li { line-height: 1.65; }
    ul { margin: 12px 0; padding-left: 24px; }
    li { margin-bottom: 4px; }
    strong { font-weight: 700; color: var(--text); }
    em { font-style: italic; color: var(--text); }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background:#0f1620; border:1px solid var(--border); padding: 2px 6px; border-radius:6px; font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, monospace; font-size: 0.9em; }
    pre { background:#0f1620; border:1px solid var(--border); padding: 12px; border-radius: 12px; overflow:auto; position: relative; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; background: #0d141b; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
    th { background: #141b24; color: var(--text); font-weight: 600; padding: 12px; text-align: left; border-bottom: 2px solid var(--border); }
    td { padding: 10px 12px; border-bottom: 1px solid var(--border); color: var(--text); }
    tr:last-child td { border-bottom: none; }
    tr:hover { background: #0f1620; }
    .copy-btn { position:absolute; top:8px; right:8px; font-size:12px; padding:6px 8px; border-radius:8px; background:#1a2740; }
    .card { border:1px solid var(--border); background:#0d141b; border-radius:12px; padding:12px; }
    .inline-form { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pill { border:1px solid var(--border); padding:4px 8px; border-radius:999px; }
    .flex { display:flex; }
    .gap-8 { gap:8px; }
    .gap-12 { gap:12px; }
    .space-between { justify-content: space-between; }
    .right { justify-content: flex-end; }
    .mark-complete { background: #203a2e; border:1px solid #284a3a; }
    .complete { color: var(--good); font-weight: 700; }

    /* Drag and drop lists */
    .dd-list { display:flex; gap:10px; flex-wrap:wrap; }
    .dd-item { padding:8px 10px; background:#0c1219; border:1px dashed var(--border); border-radius:8px; cursor: grab; }
    .dropzone { min-height:48px; border:1px dashed var(--border); padding:8px; border-radius:10px; background:#0a0f15; }

    /* Matching pairs */
    .match-grid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    .match-col { border:1px solid var(--border); padding:10px; border-radius:10px; }
    .match-item { padding:8px; border:1px dashed var(--border); border-radius:8px; background:#0c1219; margin-bottom:8px; cursor: grab; }

    /* Flowchart */
    .flow-wrap { display:grid; grid-template-columns: 260px 1fr; gap:12px; }
    .flow-tools { border:1px solid var(--border); border-radius:12px; padding:10px; background:#0d141b; }
    .flow-canvas { position:relative; border:1px solid var(--border); border-radius:12px; background:#0b1118; height:420px; overflow:hidden; }
    .node { position:absolute; padding:10px 12px; background:#132235; border:1px solid var(--border); color:var(--text); border-radius:10px; cursor: move; user-select: none; }
    .node .handle { font-size:11px; opacity:.8; }
    .flow-svg { position:absolute; inset:0; pointer-events:none; }

    .toggle-row { display:flex; gap:8px; align-items:center; }
    .hidden { display:none !important; }

    /* Summary Page Styles */
    .summary-page {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }

    .completion-banner {
      text-align: center;
      padding: 40px 20px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      border-radius: 16px;
      margin-bottom: 24px;
      color: white;
    }

    .completion-banner h1 {
      font-size: 48px;
      margin: 0 0 12px;
    }

    .completion-banner h2 {
      font-size: 24px;
      font-weight: 600;
      margin: 0 0 8px;
    }

    .completion-banner p {
      font-size: 16px;
      opacity: 0.95;
    }

    .progress-summary {
      margin-bottom: 24px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 20px;
      margin-top: 16px;
    }

    .stat-item {
      text-align: center;
      padding: 20px;
      background: #0a0f15;
      border: 1px solid var(--border);
      border-radius: 12px;
    }

    .stat-number {
      display: block;
      font-size: 48px;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 8px;
    }

    .stat-label {
      display: block;
      font-size: 14px;
      color: var(--muted);
    }

    .skills-recap, .final-checklist, .quick-reference, 
    .next-steps, .resources, .feedback-section, .answers-review {
      margin-bottom: 24px;
    }

    .skills-recap ul, .next-steps ul {
      list-style: none;
      padding-left: 0;
    }

    .skills-recap li, .next-steps li {
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }

    .skills-recap li:last-child, .next-steps li:last-child {
      border-bottom: none;
    }

    .resource-links {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .resource-links a {
      display: block;
      padding: 12px;
      background: #0a0f15;
      border: 1px solid var(--border);
      border-radius: 8px;
      text-align: center;
      transition: all 0.2s;
    }

    .resource-links a:hover {
      background: var(--accent);
      text-decoration: none;
      transform: translateY(-2px);
    }

    .completion-certificate {
      background: linear-gradient(135deg, #1a2332, #0d141b);
      border: 2px solid var(--accent);
    }

    .certificate-box {
      text-align: center;
      padding: 30px;
    }

    .student-name-display {
      font-size: 32px;
      font-weight: 700;
      color: var(--accent);
      margin: 16px 0;
    }

    .completion-date {
      font-style: italic;
      color: var(--muted);
      margin: 16px 0 24px;
    }

    .rating-stars {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 12px 0;
    }

    .rating-stars .star {
      background: transparent;
      border: none;
      font-size: 32px;
      cursor: pointer;
      transition: transform 0.2s;
      filter: grayscale(100%);
      opacity: 0.5;
    }

    .rating-stars .star:hover,
    .rating-stars .star.selected {
      filter: grayscale(0%);
      opacity: 1;
      transform: scale(1.2);
    }

    .feedback-form textarea {
      width: 100%;
      background: #0c1219;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 12px;
      border-radius: 8px;
      margin: 12px 0;
      font-family: inherit;
      resize: vertical;
    }

    .summary-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 32px;
      padding: 24px 0;
    }

    .summary-actions button {
      flex: 1;
      min-width: 160px;
      max-width: 200px;
    }

    /* Print */
    @media print {
      body { background:white; color:#000; }
      .sidebar, .topbar, .no-print { display:none !important; }
      .main { padding:0; }
      .content { max-width: none; padding:0; }
      .card, pre, .flow-tools, .flow-canvas { border-color:#ddd; }
      .stage-section { break-inside: avoid; }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <aside class="sidebar">
      <div class="brand" id="brandName">Technical Skill Tutor</div>
      
      <div style="margin-bottom:12px">
        <label class="muted" style="display:block; margin-bottom:4px">Select Guide:</label>
        <select id="guideSelector" style="width:100%; background:#0c1219; border:1px solid var(--border); color:var(--text); padding:8px; border-radius:8px;">
          <option value="">Loading guides...</option>
        </select>
      </div>

      <div class="student-box">
        <input id="studentName" type="text" placeholder="Enter your name to save progress" />
        <button id="saveName">Save</button>
      </div>
      <div class="toggle-row">
        <span class="muted">Instructor mode</span>
        <button id="instructorBtn" class="secondary" title="Toggle instructor mode">OFF</button>
      </div>
      <div class="muted" style="margin-top:6px">Passcode required</div>

      <div class="stage-list" id="stageList"></div>
      <div class="muted" style="margin-top:12px">Tip: Use Next/Prev at the bottom of each section.</div>
      <div style="margin-top:14px">
        <button id="printStage" class="secondary" title="Print current stage">Print current stage</button>
      </div>
    </aside>

    <main class="main">
      <div class="topbar">
        <div class="content">
          <div class="breadcrumbs">
            <span>Stage:</span>
            <span class="stage-chip" id="bcStage">â€”</span>
            <span>Section:</span>
            <span class="stage-chip" id="bcSection">â€”</span>
          </div>
          <div class="progress-wrap">
            <div class="meter"><div id="meterBar"></div></div>
            <div class="muted" id="meterText" style="margin-top:6px"></div>
          </div>
        </div>
      </div>

      <div class="content" id="content"></div>
    </main>
  </div>

  <script>
  // ------------------------------
  // DATA MODEL (loaded from JSON)
  // ------------------------------
  let GUIDE_DATA = null;  // Full JSON data
  let STAGES = [];
  let SECTIONS = [];
  let GUIDE = {};  // Content organized by stage/section

  // ------------------------------
  // GUIDE LOADING
  // ------------------------------
  // Helper function to get section display name, converting ID to readable format if needed
  function getSectionDisplayName(section) {
    if (section.displayName) return section.displayName;
    // Convert camelCase ID to Title Case (e.g., "guidedPractice" -> "Guided Practice")
    return section.id
      .replace(/([A-Z])/g, ' $1') // Add space before capital letters
      .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
      .trim();
  }
  
  async function loadGuide(path) {
    try {
      const response = await fetch(path);
      if (!response.ok) throw new Error('Failed to load guide');
      
      GUIDE_DATA = await response.json();
      
      // Extract data from JSON structure
      STAGES = GUIDE_DATA.stages;
      SECTIONS = GUIDE_DATA.sections.map(s => getSectionDisplayName(s));
      
      // Transform content from JSON format to internal format
      GUIDE = {};
      for (const stageId in GUIDE_DATA.content) {
        GUIDE[stageId] = {};
        for (const sectionId in GUIDE_DATA.content[stageId]) {
          const secData = GUIDE_DATA.content[stageId][sectionId];
          const section = GUIDE_DATA.sections.find(s => s.id === sectionId);
          const displayName = section ? getSectionDisplayName(section) : sectionId;
          const secKey = displayName.replace(/\s+/g,'');
          
          // Convert JSON components to old format for compatibility
          GUIDE[stageId][secKey] = {
            h: secData.heading,
            components: secData.components
          };
        }
      }
      
      // Update UI with guide metadata
      document.getElementById('brandName').textContent = GUIDE_DATA.branding.brandName;
      document.title = GUIDE_DATA.metadata.title + ' â€” ' + GUIDE_DATA.metadata.subtitle;
      
      // Reset state and render
      state.stageIndex = 0;
      state.sectionIndex = 0;
      state.completed = {};
      state.answers = {};
      
      renderAll();
      
    } catch (error) {
      console.error('Error loading guide:', error);
      alert('Failed to load guide. Please check the console for details.');
    }
  }
  
  async function populateGuideSelector() {
    const selector = document.getElementById('guideSelector');
    selector.innerHTML = '<option value="">Loading guides...</option>';

    try {
      const response = await fetch('guides/manifest.json');
      if (!response.ok) throw new Error('Failed to load guide list');
      const guides = await response.json();
      if (!Array.isArray(guides) || guides.length === 0) throw new Error('No guides in manifest');

      selector.innerHTML = '';
      guides.forEach(guide => {
        const option = document.createElement('option');
        option.value = guide.value;
        option.textContent = guide.label;
        selector.appendChild(option);
      });

      const savedGuide = localStorage.getItem('selected_guide');
      const selectedValue = savedGuide && guides.some(g => g.value === savedGuide)
        ? savedGuide
        : guides[0].value;
      selector.value = selectedValue;
      await loadGuide(selectedValue);
    } catch (err) {
      console.error('Error loading guide list:', err);
      selector.innerHTML = '';
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'No guides found';
      option.disabled = true;
      selector.appendChild(option);
    }
  }

  // ------------------------------
  // STATE & STORAGE
  // ------------------------------
  const state = {
    student: '',
    instructor: false,
    stageIndex: 0,
    sectionIndex: 0,
    completed: {}, // completed[stageId][section]
    answers: {}, // answers[stageId][section][componentIndex] = answerData
    showSummary: false, // Show summary page when true
  };

  function storageKey(name){ 
    const prefix = GUIDE_DATA?.metadata?.storageKeyPrefix || 'guide';
    return `${prefix}_${name||state.student||'anon'}`; 
  }
  function save(){ if(!state.student) return; const data = { completed: state.completed, answers: state.answers, last: [state.stageIndex,state.sectionIndex], showSummary: state.showSummary }; localStorage.setItem(storageKey(), JSON.stringify(data)); }
  function load(name){ const raw = localStorage.getItem(storageKey(name)); if(!raw) return; try{ const data = JSON.parse(raw); state.completed = data.completed||{}; state.answers = data.answers||{}; state.showSummary = data.showSummary||false; const [si,ci] = data.last||[0,0]; state.stageIndex=si; state.sectionIndex=ci; }catch(e){} }

  // ------------------------------
  // UI HELPERS
  // ------------------------------
  const el = (sel)=>document.querySelector(sel);
  const contentEl = el('#content');

  function setBreadcrumbs(){
    if (state.showSummary) {
      el('#bcStage').textContent = 'Complete';
      el('#bcSection').textContent = 'Summary';
    } else {
      el('#bcStage').textContent = STAGES[state.stageIndex].title;
      el('#bcSection').textContent = SECTIONS[state.sectionIndex];
    }
  }
  function computeProgress(){
    const total = STAGES.length * SECTIONS.length;
    let done = 0;
    for(const s of STAGES){
      const c = state.completed[s.id]||{};
      done += Object.keys(c).filter(k=>c[k]).length;
    }
    const pct = Math.round((done/total)*100);
    el('#meterBar').style.width = pct + '%';
    el('#meterText').textContent = `${pct}% complete Â· Stage ${state.stageIndex} of ${STAGES.length-1} (${STAGES[state.stageIndex].short})`;
  }

  function markComplete(stageId, section, val=true){
    if(!state.completed[stageId]) state.completed[stageId]={};
    state.completed[stageId][section]=val;
    save();
    renderSidebar();
    computeProgress();
  }

  function sectionCompleted(stageId, section){
    return !!(state.completed[stageId] && state.completed[stageId][section]);
  }

  function copyText(txt){
    navigator.clipboard.writeText(txt).then(()=>{
      alert('Copied to clipboard');
    });
  }

  // Answer storage helpers
  function saveAnswer(stageId, section, componentIndex, answerData){
    if(!state.answers[stageId]) state.answers[stageId]={};
    if(!state.answers[stageId][section]) state.answers[stageId][section]={};
    state.answers[stageId][section][componentIndex] = answerData;
    save();
  }

  function getAnswer(stageId, section, componentIndex){
    return state.answers[stageId]?.[section]?.[componentIndex];
  }

  function makeCopyBlock(codeText){
    const pre = document.createElement('pre');
    pre.textContent = codeText;
    const btn = document.createElement('button');
    btn.className='copy-btn'; btn.textContent='Copy';
    btn.addEventListener('click', ()=>copyText(codeText));
    pre.appendChild(btn);
    return pre;
  }

  // ------------------------------
  // MARKDOWN PARSER
  // ------------------------------
  function parseMarkdown(text) {
    if (!text) return '';
    
    // Parse markdown tables first (before HTML escaping)
    // Tables are identified by lines starting with | and containing |
    const lines = text.split('\n');
    const processed = [];
    let inTable = false;
    let tableRows = [];
    const tablePlaceholders = [];
    let placeholderIndex = 0;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      
      // Check if this is a table row (starts with | and contains |)
      const isTableRow = /^\|.+?\|/.test(trimmedLine);
      const isTableSeparator = /^\|[\s\-\|:]+?\|/.test(trimmedLine);
      
      if (isTableRow || isTableSeparator) {
        if (!inTable) {
          inTable = true;
          tableRows = [];
        }
        tableRows.push(trimmedLine);
      } else {
        // Not a table row - process any accumulated table
        if (inTable && tableRows.length > 0) {
          const placeholder = `__TABLE_PLACEHOLDER_${placeholderIndex}__`;
          // Parse table with markdown applied to cells
          tablePlaceholders.push({ placeholder, html: parseMarkdownTable(tableRows, true) });
          processed.push(placeholder);
          placeholderIndex++;
          tableRows = [];
          inTable = false;
        }
        processed.push(line);
      }
    }
    
    // Process any remaining table
    if (inTable && tableRows.length > 0) {
      const placeholder = `__TABLE_PLACEHOLDER_${placeholderIndex}__`;
      tablePlaceholders.push({ placeholder, html: parseMarkdownTable(tableRows, true) });
      processed.push(placeholder);
    }
    
    let html = processed.join('\n');
    
    // Escape HTML to prevent XSS (but preserve table placeholders)
    html = html
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    
    // Parse markdown syntax (before replacing table placeholders, so markdown in tables works)
    // Bold: **text** â†’ <strong>text</strong>
    html = html.replace(/\*\*([^\*]+?)\*\*/g, '<strong>$1</strong>');
    
    // Italic: *text* â†’ <em>text</em> (but not if it's part of **)
    html = html.replace(/(?<!\*)\*([^\*\n]+?)\*(?!\*)/g, '<em>$1</em>');
    
    // Inline code: `text` â†’ <code>text</code>
    html = html.replace(/`([^`]+?)`/g, '<code>$1</code>');
    
    // Links: [text](url) â†’ <a href="url">text</a>
    html = html.replace(/\[([^\]]+?)\]\(([^\)]+?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    
    // Bullet lists: Convert lines starting with â€¢ into <ul><li> structure
    // Split by line breaks and process
    const lines2 = html.split('\n');
    const processed2 = [];
    let inList = false;
    
    for (let i = 0; i < lines2.length; i++) {
      const line = lines2[i];
      const trimmedLine = line.trim();
      
      // Skip if this is already a table (contains <table>)
      if (trimmedLine.includes('<table>')) {
        processed2.push(line);
        continue;
      }
      
      // Check if line starts with bullet symbol â€¢
      if (/^â€¢\s/.test(trimmedLine)) {
        if (!inList) {
          processed2.push('<ul>');
          inList = true;
        }
        // Remove the bullet and add as list item
        const content = trimmedLine.replace(/^â€¢\s*/, '');
        processed2.push(`<li>${content}</li>`);
      } else if (trimmedLine === '' && inList) {
        // Empty line while in list - skip it (don't close the list)
        continue;
      } else {
        // Non-empty, non-bullet line - close list if open
        if (inList) {
          processed2.push('</ul>');
          inList = false;
        }
        processed2.push(line);
      }
    }
    
    // Close any open list at the end
    if (inList) {
      processed2.push('</ul>');
    }
    
    html = processed2.join('\n');
    
    // Remove newlines around list elements to prevent extra spacing
    html = html.replace(/\n(<ul>)/g, '$1');
    html = html.replace(/(<ul>)\n/g, '$1');
    html = html.replace(/\n(<li>)/g, '$1');
    html = html.replace(/(<\/li>)\n/g, '$1');
    html = html.replace(/\n(<\/ul>)/g, '$1');
    html = html.replace(/(<\/ul>)\n/g, '$1<br>');
    
    // Line breaks: convert remaining \n to <br> (for non-list, non-table content)
    html = html.replace(/\n/g, '<br>');
    
    // Replace table placeholders with actual table HTML (after all markdown processing)
    tablePlaceholders.forEach(({ placeholder, html: tableHtml }) => {
      html = html.replace(placeholder, tableHtml);
    });
    
    return html;
  }
  
  // Helper function to parse markdown table syntax
  // Note: This is called before main markdown parsing, so we need to apply markdown to cells
  function parseMarkdownTable(tableRows, applyMarkdownToCells) {
    if (tableRows.length < 2) return ''; // Need at least header and separator
    
    const headerRow = tableRows[0];
    const separatorRow = tableRows[1];
    const dataRows = tableRows.slice(2);
    
    // Parse header
    const headerCells = headerRow.split('|').map(c => c.trim()).filter(c => c);
    
    // Parse data rows
    const rows = dataRows.map(row => {
      return row.split('|').map(c => c.trim()).filter(c => c);
    });
    
    // Build HTML table with markdown applied to cell content
    let tableHtml = '<table><thead><tr>';
    headerCells.forEach(cell => {
      const processed = applyMarkdownToCells ? parseMarkdownInline(cell) : escapeHtml(cell);
      tableHtml += `<th>${processed}</th>`;
    });
    tableHtml += '</tr></thead><tbody>';
    
    rows.forEach(row => {
      tableHtml += '<tr>';
      // Ensure we have the same number of cells as headers
      for (let i = 0; i < headerCells.length; i++) {
        const cell = row[i] || '';
        const processed = applyMarkdownToCells ? parseMarkdownInline(cell) : escapeHtml(cell);
        tableHtml += `<td>${processed}</td>`;
      }
      tableHtml += '</tr>';
    });
    
    tableHtml += '</tbody></table>';
    return tableHtml;
  }
  
  // Helper to escape HTML
  function escapeHtml(text) {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }
  
  // Helper to apply inline markdown (bold, italic, code, links) without block elements
  function parseMarkdownInline(text) {
    if (!text) return '';
    let html = escapeHtml(text);
    // Bold: **text** â†’ <strong>text</strong>
    html = html.replace(/\*\*([^\*]+?)\*\*/g, '<strong>$1</strong>');
    // Italic: *text* â†’ <em>text</em> (but not if it's part of **)
    html = html.replace(/(?<!\*)\*([^\*\n]+?)\*(?!\*)/g, '<em>$1</em>');
    // Inline code: `text` â†’ <code>text</code>
    html = html.replace(/`([^`]+?)`/g, '<code>$1</code>');
    // Links: [text](url) â†’ <a href="url">text</a>
    html = html.replace(/\[([^\]]+?)\]\(([^\)]+?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
    return html;
  }

  // ------------------------------
  // INTERACTIVES
  // ------------------------------
  
  // Fisher-Yates shuffle algorithm for randomizing arrays
  function shuffleArray(array) {
    const shuffled = [...array]; // Create a copy to avoid mutating original
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  function mcqComponent(mcq, stageId, section, componentIndex){
    const wrap = document.createElement('div');
    wrap.className='card';
    const q = document.createElement('p');
    q.innerHTML = parseMarkdown(mcq.q); wrap.appendChild(q);
    const id = 'mcq_'+Math.random().toString(36).slice(2);
    
    // Restore saved answer
    const savedAnswer = getAnswer(stageId, section, componentIndex);
    
    // Shuffle options while tracking the correct answer
    let shuffledOptions;
    let correctAnswerText = mcq.options[mcq.correct];
    
    if(savedAnswer?.shuffledOptions) {
      // Restore previously shuffled order
      shuffledOptions = savedAnswer.shuffledOptions;
    } else {
      // First load: create shuffled options with original indices
      const optionsWithIndices = mcq.options.map((opt, idx) => ({ text: opt, originalIndex: idx }));
      const shuffled = shuffleArray(optionsWithIndices);
      shuffledOptions = shuffled.map(item => item.text);
      
      // Save the shuffled order
      saveAnswer(stageId, section, componentIndex, { shuffledOptions });
    }
    
    shuffledOptions.forEach((opt, i)=>{
      const row = document.createElement('div');
      row.className='inline-form';
      const r = document.createElement('input'); r.type='radio'; r.name=id; r.value=i;
      
      // Restore selection
      if(savedAnswer !== undefined && savedAnswer.selected === i) {
        r.checked = true;
      }
      
      // Save on change
      r.addEventListener('change', ()=>{
        const currentAnswer = getAnswer(stageId, section, componentIndex) || {};
        saveAnswer(stageId, section, componentIndex, { ...currentAnswer, selected: i });
      });
      
      const lbl = document.createElement('label'); lbl.innerHTML = parseMarkdown(opt); lbl.style.marginLeft='6px';
      row.appendChild(r); row.appendChild(lbl); wrap.appendChild(row);
    });
    const fb = document.createElement('div'); fb.className='muted'; fb.style.marginTop='6px';
    
    // Restore feedback if previously checked
    if(savedAnswer?.checked !== undefined) {
      if(savedAnswer.checked) {
        fb.textContent = 'Correct!'; 
        fb.classList.add('complete');
      } else {
        fb.textContent = 'Not quite â€” try again.'; 
        fb.classList.remove('complete');
      }
    }
    
    const btn = document.createElement('button'); btn.textContent='Check answer'; btn.onclick=()=>{
      const pick = wrap.querySelector('input[type=radio]:checked');
      if(!pick){ fb.textContent='Choose an option'; return; }
      const selectedText = shuffledOptions[+pick.value];
      const isCorrect = selectedText === correctAnswerText;
      if(isCorrect){ fb.textContent='Correct!'; fb.classList.add('complete'); } else { fb.textContent='Not quite â€” try again.'; fb.classList.remove('complete'); }
      
      // Save checked state
      const currentAnswer = getAnswer(stageId, section, componentIndex) || {};
      saveAnswer(stageId, section, componentIndex, { ...currentAnswer, selected: +pick.value, checked: isCorrect });
    };
    wrap.appendChild(btn); wrap.appendChild(fb);
    if(state.instructor){ const ans=document.createElement('div'); ans.className='muted'; ans.textContent='(Answer: '+correctAnswerText+')'; wrap.appendChild(ans); }
    return wrap;
  }

  function shortAnswerComponent(cfg, stageId, section, componentIndex){
    const wrap=document.createElement('div'); wrap.className='card';
    const p=document.createElement('p'); p.innerHTML=parseMarkdown(cfg.prompt); wrap.appendChild(p);
    const ta=document.createElement('input'); ta.type='text'; ta.style.width='100%'; ta.placeholder='Type here...'; ta.setAttribute('aria-label','Short answer');
    
    // Restore saved answer
    const savedAnswer = getAnswer(stageId, section, componentIndex);
    if(savedAnswer?.text) {
      ta.value = savedAnswer.text;
    }
    
    // Save on input (with debounce)
    let saveTimeout;
    ta.addEventListener('input', ()=>{
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(()=>{
        saveAnswer(stageId, section, componentIndex, { text: ta.value });
      }, 500); // Debounce for 500ms
    });
    
    wrap.appendChild(ta);
    
    // Verify with ChatGPT button
    const verifyBtn=document.createElement('button'); 
    verifyBtn.textContent='Verify with ChatGPT';
    verifyBtn.style.marginTop='8px';
    verifyBtn.onclick=()=>{
      const val=(ta.value||'').trim();
      if(!val){ alert('Please enter your answer first'); return; }
      
      // Build context section
      let contextSection = '';
      if(cfg.sectionContext && cfg.sectionContext.length > 0) {
        contextSection = `\n\nContext from the lesson (for reference):\n${cfg.sectionContext.join('\n\n')}`;
      }
      
      // Generate ChatGPT prompt with full context
      const chatGPTPrompt = `You are a helpful tutor evaluating student answers. Please review this answer and provide brief, encouraging feedback.

Stage: ${cfg.stageTitle || 'N/A'}
Section: ${cfg.sectionTitle || 'N/A'}${contextSection}

Question: ${cfg.prompt}

Student Answer: ${val}

Please evaluate if this answer is correct and complete based on the lesson context above. Provide constructive feedback in 2-3 sentences.`;
      
      // Hide the verify button and show the prompt in a code block
      verifyBtn.style.display='none';
      const promptBlock = makeCopyBlock(chatGPTPrompt);
      const instruction = document.createElement('div');
      instruction.className='muted';
      instruction.style.marginTop='8px';
      instruction.innerHTML='<strong>Copy the prompt below and paste it into ChatGPT:</strong>';
      wrap.appendChild(instruction);
      wrap.appendChild(promptBlock);
    };
    wrap.appendChild(verifyBtn);
    
    return wrap;
  }

  function checklistComponent(items, stageId, section, componentIndex){
    const wrap=document.createElement('div'); wrap.className='card';
    
    // Restore saved answers
    const savedAnswer = getAnswer(stageId, section, componentIndex);
    
    items.forEach((txt,i)=>{
      const row=document.createElement('div'); row.className='inline-form';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.id='cb'+i+'_'+componentIndex;
      
      // Restore checked state
      if(savedAnswer?.checked && savedAnswer.checked[i]) {
        cb.checked = true;
      }
      
      // Save on change
      cb.addEventListener('change', ()=>{
        const checkedStates = {};
        items.forEach((_, idx)=>{
          const checkbox = wrap.querySelector(`#cb${idx}_${componentIndex}`);
          if(checkbox) checkedStates[idx] = checkbox.checked;
        });
        saveAnswer(stageId, section, componentIndex, { checked: checkedStates });
      });
      
      const lbl=document.createElement('label'); lbl.innerHTML=parseMarkdown(txt); lbl.htmlFor=cb.id; lbl.style.marginLeft='6px';
      row.appendChild(cb); row.appendChild(lbl); wrap.appendChild(row);
    });
    return wrap;
  }

  function orderComponent(items, stageId, section, componentIndex){
    const wrap=document.createElement('div');
    const note=document.createElement('div'); note.className='muted'; note.textContent='Drag to reorder into the correct sequence.'; wrap.appendChild(note);
    const list=document.createElement('div'); list.className='dd-list';
    
    // Restore saved order or use shuffled items on first load
    const savedAnswer = getAnswer(stageId, section, componentIndex);
    let orderedItems;
    if(savedAnswer?.order) {
      // Restore previously saved order
      orderedItems = savedAnswer.order.map(t => ({t, key: t+"_"+Math.random().toString(36).slice(2)}));
    } else {
      // First load: shuffle the items randomly
      const shuffledItems = shuffleArray(items);
      orderedItems = shuffledItems.map((t,i)=>({t, key: i+"_"+Math.random().toString(36).slice(2)}));
    }
    
    orderedItems.forEach(obj=>{
      const d=document.createElement('div'); d.className='dd-item'; d.draggable=true; d.innerHTML=parseMarkdown(obj.t); d.dataset.key=obj.key; d.dataset.plainText=obj.t; list.appendChild(d);
    });
    wrap.appendChild(list);
    let dragEl=null;
    
    function saveCurrentOrder(){
      const current=[...list.children].map(el=>el.dataset.plainText);
      saveAnswer(stageId, section, componentIndex, { order: current });
    }
    
    list.addEventListener('dragstart',e=>{ if(e.target.classList.contains('dd-item')){ dragEl=e.target; e.dataTransfer.setData('text/plain', dragEl.dataset.key);} });
    list.addEventListener('dragover',e=>{ e.preventDefault(); const tgt=e.target.closest('.dd-item'); if(!tgt||tgt===dragEl) return; const rect=tgt.getBoundingClientRect(); const before= (e.clientX - rect.left) < rect.width/2; list.insertBefore(dragEl, before? tgt: tgt.nextSibling); });
    list.addEventListener('dragend', saveCurrentOrder);
    
    const btn=document.createElement('button'); btn.textContent='Check order'; btn.style.marginTop='8px';
    const fb=document.createElement('div'); fb.className='muted'; fb.style.marginTop='6px';
    
    // Restore feedback if previously checked
    if(savedAnswer?.checked !== undefined) {
      fb.textContent = savedAnswer.checked ? 'Correct order!' : 'Something is off â€” try again.';
      fb.classList.toggle('complete', savedAnswer.checked);
    }
    
    btn.onclick=()=>{
      const current=[...list.children].map(el=>el.dataset.plainText || el.textContent);
      const correct=items;
      const ok=current.every((t,i)=>t===correct[i]);
      fb.textContent= ok? 'Correct order!':'Something is off â€” try again.';
      fb.classList.toggle('complete', ok);
      
      // Save checked state
      saveAnswer(stageId, section, componentIndex, { order: current, checked: ok });
    };
    wrap.appendChild(btn); wrap.appendChild(fb);
    return wrap;
  }

  function matchComponent(cfg, stageId, section, componentIndex){
    const wrap=document.createElement('div');
    const grid=document.createElement('div'); grid.className='match-grid';
    const left=document.createElement('div'); left.className='match-col';
    const right=document.createElement('div'); right.className='match-col';
    const rights=Object.keys(cfg.right);
    
    // Restore saved matches
    const savedAnswer = getAnswer(stageId, section, componentIndex);
    
    // Shuffle both columns for initial display (but not when restoring)
    const leftItems = shuffleArray(cfg.left);
    const rightItems = shuffleArray(rights);
    
    leftItems.forEach((term,i)=>{
      const item=document.createElement('div'); item.className='match-item'; item.draggable=true; item.innerHTML=parseMarkdown(term); item.dataset.term=term; left.appendChild(item);
    });
    rightItems.forEach((def, idx)=>{
      const zone=document.createElement('div'); zone.className='dropzone'; zone.dataset.accept=cfg.right[def]; zone.dataset.defIndex=idx;
      
      // Restore matched term
      if(savedAnswer?.matches && savedAnswer.matches[idx]) {
        zone.textContent = savedAnswer.matches[idx];
        zone.dataset.filled = savedAnswer.matches[idx];
      }
      
      const label=document.createElement('div'); label.className='muted'; label.innerHTML=parseMarkdown(def); right.appendChild(label); right.appendChild(zone);
    });
    grid.appendChild(left); grid.appendChild(right); wrap.appendChild(grid);
    let dragging=null;
    
    function saveMatches(){
      const zones=[...wrap.querySelectorAll('.dropzone')];
      const matches = {};
      zones.forEach(z => {
        const idx = z.dataset.defIndex;
        if(z.dataset.filled) {
          matches[idx] = z.dataset.filled;
        }
      });
      saveAnswer(stageId, section, componentIndex, { matches });
    }
    
    wrap.addEventListener('dragstart',e=>{ if(e.target.classList.contains('match-item')){ dragging=e.target; }});
    wrap.addEventListener('dragover',e=>{ if(e.target.classList.contains('dropzone')) e.preventDefault(); });
    wrap.addEventListener('drop',e=>{ 
      if(e.target.classList.contains('dropzone')){ 
        e.preventDefault(); 
        if(dragging){ 
          e.target.textContent=dragging.dataset.term; 
          e.target.dataset.filled=dragging.dataset.term; 
          saveMatches();
        } 
      }
    });
    const btn=document.createElement('button'); btn.textContent='Check matches'; btn.style.marginTop='8px';
    const fb=document.createElement('div'); fb.className='muted'; fb.style.marginTop='6px';
    
    // Restore feedback if previously checked
    if(savedAnswer?.checked !== undefined) {
      fb.textContent = savedAnswer.checked ? 'All matched!' : 'Some pairs are incorrect.';
      fb.classList.toggle('complete', savedAnswer.checked);
    }
    
    btn.onclick=()=>{
      const zones=[...wrap.querySelectorAll('.dropzone')];
      const ok=zones.every(z=>z.dataset.filled===z.dataset.accept);
      fb.textContent= ok? 'All matched!':'Some pairs are incorrect.'; 
      fb.classList.toggle('complete', ok);
      
      // Save checked state
      const matches = {};
      zones.forEach(z => {
        const idx = z.dataset.defIndex;
        if(z.dataset.filled) matches[idx] = z.dataset.filled;
      });
      saveAnswer(stageId, section, componentIndex, { matches, checked: ok });
    };
    wrap.appendChild(btn); wrap.appendChild(fb);
    if(state.instructor){ const ans=document.createElement('div'); ans.className='muted'; ans.style.marginTop='6px'; ans.textContent='(Answer key visible in instructor mode.)'; wrap.appendChild(ans); }
    return wrap;
  }

  // Table component: renders structured table data
  function tableComponent(cfg, stageId, section, componentIndex){
    const wrap = document.createElement('div');
    wrap.className = 'card';
    
    // Optional caption
    if (cfg.caption) {
      const caption = document.createElement('div');
      caption.className = 'muted';
      caption.style.marginBottom = '8px';
      caption.innerHTML = parseMarkdown(cfg.caption);
      wrap.appendChild(caption);
    }
    
    const table = document.createElement('table');
    
    // Header row
    if (cfg.headers && cfg.headers.length > 0) {
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      cfg.headers.forEach(header => {
        const th = document.createElement('th');
        th.innerHTML = parseMarkdown(header);
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
    }
    
    // Body rows
    if (cfg.rows && cfg.rows.length > 0) {
      const tbody = document.createElement('tbody');
      cfg.rows.forEach(row => {
        const tr = document.createElement('tr');
        // Handle both array of cells and object with cell keys
        if (Array.isArray(row)) {
          row.forEach(cell => {
            const td = document.createElement('td');
            td.innerHTML = parseMarkdown(cell);
            tr.appendChild(td);
          });
        } else if (typeof row === 'object') {
          // If row is an object, use headers to determine order
          cfg.headers.forEach(header => {
            const td = document.createElement('td');
            const cellValue = row[header] || '';
            td.innerHTML = parseMarkdown(cellValue);
            tr.appendChild(td);
          });
        }
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
    }
    
    wrap.appendChild(table);
    return wrap;
  }

  // Basic mini flowchart: draggable nodes, sequential connectors
  function flowchartComponent(cfg, stageId, section, componentIndex){
    const wrap=document.createElement('div'); wrap.className='flow-wrap';
    const tools=document.createElement('div'); tools.className='flow-tools';
    const canvas=document.createElement('div'); canvas.className='flow-canvas';
    const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.classList.add('flow-svg'); canvas.appendChild(svg);

    const nodes=[];
    
    function saveNodes(){
      const nodeData = nodes.map(n => ({
        x: parseInt(n.style.left),
        y: parseInt(n.style.top),
        text: n.querySelector('[contenteditable]').textContent,
        id: n.dataset.id
      }));
      saveAnswer(stageId, section, componentIndex, { nodes: nodeData });
    }

    function addNode(x=40,y=40,text='Step'){
      const n=document.createElement('div'); n.className='node'; n.style.left=x+'px'; n.style.top=y+'px';
      n.innerHTML = `<div class="handle">drag</div><div contenteditable="true" spellcheck="false">${text}</div>`;
      n.dataset.id = 'n'+Math.random().toString(36).slice(2);
      
      // Save on text edit
      const editableDiv = n.querySelector('[contenteditable]');
      editableDiv.addEventListener('blur', saveNodes);
      editableDiv.addEventListener('input', ()=>{
        clearTimeout(editableDiv._saveTimeout);
        editableDiv._saveTimeout = setTimeout(saveNodes, 1000);
      });
      
      canvas.appendChild(n);
      enableDrag(n);
      nodes.push(n);
      drawLines();
      saveNodes();
    }

    function enableDrag(el){
      let offX=0, offY=0, dragging=false;
      el.addEventListener('mousedown', (e)=>{ if(e.target.contentEditable === 'true') return; dragging=true; offX=e.offsetX; offY=e.offsetY; });
      window.addEventListener('mousemove', (e)=>{ if(!dragging) return; const rect=canvas.getBoundingClientRect(); let x=e.clientX-rect.left-offX; let y=e.clientY-rect.top-offY; x=Math.max(8, Math.min(rect.width-140, x)); y=Math.max(8, Math.min(rect.height-44, y)); el.style.left=x+'px'; el.style.top=y+'px'; drawLines(); });
      window.addEventListener('mouseup', ()=> { if(dragging) saveNodes(); dragging=false; });
    }

    function drawLines(){
      // simple sequential connectors in creation order
      while(svg.firstChild) svg.removeChild(svg.firstChild);
      for(let i=0;i<nodes.length-1;i++){
        const a=nodes[i].getBoundingClientRect();
        const b=nodes[i+1].getBoundingClientRect();
        const cr=canvas.getBoundingClientRect();
        const x1=a.left - cr.left + a.width/2;
        const y1=a.top - cr.top + a.height/2;
        const x2=b.left - cr.left + b.width/2;
        const y2=b.top - cr.top + b.height/2;
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        const dx=(x2-x1)/2;
        const d=`M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;
        path.setAttribute('d', d); path.setAttribute('fill','none'); path.setAttribute('stroke','#3d74a8'); path.setAttribute('stroke-width','2');
        svg.appendChild(path);
      }
    }

    // tools
    const addBtn=document.createElement('button'); addBtn.textContent='Add step'; addBtn.onclick=()=>addNode(40+nodes.length*40, 60, 'New step');
    const seqBtn=document.createElement('button'); seqBtn.className='secondary'; seqBtn.style.marginLeft='8px'; seqBtn.textContent='Auto-sequence';
    seqBtn.onclick=()=>{ nodes.sort((a,b)=> a.offsetTop - b.offsetTop || a.offsetLeft - b.offsetLeft ); drawLines(); saveNodes(); };
    tools.appendChild(addBtn); tools.appendChild(seqBtn);

    wrap.appendChild(tools); wrap.appendChild(canvas);

    // Restore saved nodes or use default
    const savedAnswer = getAnswer(stageId, section, componentIndex);
    if(savedAnswer?.nodes && savedAnswer.nodes.length > 0) {
      savedAnswer.nodes.forEach(n => addNode(n.x, n.y, n.text));
    } else {
      (cfg.nodes||[]).forEach(n=>addNode(n.x,n.y,n.text));
    }

    return wrap;
  }

  // ------------------------------
  // SUMMARY PAGE
  // ------------------------------
  function renderSummaryPage() {
    const wrap = document.createElement('div');
    wrap.className = 'summary-page';
    
    // Completion Banner
    const banner = document.createElement('div');
    banner.className = 'completion-banner';
    banner.innerHTML = `
      <h1>ðŸŽ‰ Congratulations!</h1>
      <h2>You've completed: ${GUIDE_DATA.metadata.title}</h2>
      <p>You've successfully progressed through all ${STAGES.length} stages and gained essential technical skills.</p>
    `;
    wrap.appendChild(banner);
    
    // Progress Statistics
    const progressCard = document.createElement('div');
    progressCard.className = 'progress-summary card';
    const totalSections = STAGES.length * SECTIONS.length;
    let completedSections = 0;
    for(const s of STAGES) {
      const c = state.completed[s.id] || {};
      completedSections += Object.keys(c).filter(k => c[k]).length;
    }
    
    progressCard.innerHTML = `
      <h2>Your Learning Journey</h2>
      <div class="stats-grid">
        <div class="stat-item">
          <span class="stat-number">${STAGES.length}</span>
          <span class="stat-label">Stages Completed</span>
        </div>
        <div class="stat-item">
          <span class="stat-number">${completedSections}</span>
          <span class="stat-label">Sections Finished</span>
        </div>
        <div class="stat-item">
          <span class="stat-number">${Math.round((completedSections/totalSections)*100)}%</span>
          <span class="stat-label">Progress</span>
        </div>
      </div>
    `;
    wrap.appendChild(progressCard);
    
    // Skills Learned
    const skillsCard = document.createElement('div');
    skillsCard.className = 'skills-recap card';
    const summaryData = GUIDE_DATA.summary || {};
    
    let skillsHTML = '<h2>ðŸŽ¯ Skills You\'ve Mastered</h2><ul>';
    if (summaryData.skills && summaryData.skills.length > 0) {
      skillsHTML += summaryData.skills.map(skill => 
        `<li><strong>${skill.title}</strong> - ${skill.description}</li>`
      ).join('');
    } else {
      // Default skills
      skillsHTML += `
        <li><strong>Technical Setup</strong> - Successfully configured software and system settings</li>
        <li><strong>Command Line Skills</strong> - Navigated and executed commands in terminal</li>
        <li><strong>Problem Solving</strong> - Identified and resolved common issues</li>
        <li><strong>Best Practices</strong> - Applied professional development workflows</li>
      `;
    }
    skillsHTML += '</ul>';
    skillsCard.innerHTML = skillsHTML;
    wrap.appendChild(skillsCard);
    
    // Final Checklist
    const checklistCard = document.createElement('div');
    checklistCard.className = 'final-checklist card';
    checklistCard.innerHTML = `
      <h2>âœ… Final System Check</h2>
      <p>Verify your setup is fully functional:</p>
    `;
    
    const finalChecklist = summaryData.finalChecklist || [
      'All software is properly installed',
      'System configuration is complete',
      'Test examples run successfully',
      'Development environment is ready',
      'Know where to find help if needed'
    ];
    
    finalChecklist.forEach((item, i) => {
      const row = document.createElement('div');
      row.className = 'inline-form';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.id = `final-check-${i}`;
      const lbl = document.createElement('label');
      lbl.htmlFor = cb.id;
      lbl.textContent = item;
      lbl.style.marginLeft = '6px';
      row.appendChild(cb);
      row.appendChild(lbl);
      checklistCard.appendChild(row);
    });
    wrap.appendChild(checklistCard);
    
    // Quick Reference
    if (summaryData.quickReference) {
      const refCard = document.createElement('div');
      refCard.className = 'quick-reference card';
      refCard.innerHTML = `<h2>ðŸ“ Quick Reference Guide</h2><p>Keep these essential commands handy:</p>`;
      refCard.appendChild(makeCopyBlock(summaryData.quickReference));
      wrap.appendChild(refCard);
    }
    
    // Next Steps
    const nextCard = document.createElement('div');
    nextCard.className = 'next-steps card';
    
    let nextStepsHTML = '<h2>ðŸš€ What\'s Next?</h2><p>Continue your learning journey:</p><ul>';
    if (summaryData.nextSteps && summaryData.nextSteps.length > 0) {
      nextStepsHTML += summaryData.nextSteps.map(step => 
        `<li><strong>${step.title}</strong> - ${step.description}</li>`
      ).join('');
    } else {
      // Default next steps
      nextStepsHTML += `
        <li><strong>Practice</strong> - Apply what you've learned in real projects</li>
        <li><strong>Explore</strong> - Discover advanced features and techniques</li>
        <li><strong>Connect</strong> - Join communities and share your progress</li>
      `;
    }
    nextStepsHTML += '</ul>';
    nextCard.innerHTML = nextStepsHTML;
    wrap.appendChild(nextCard);
    
    // Resources (if provided)
    if (summaryData.resources && summaryData.resources.length > 0) {
      const resourcesCard = document.createElement('div');
      resourcesCard.className = 'resources card';
      resourcesCard.innerHTML = '<h2>ðŸ“š Additional Resources</h2>';
      
      const resourceLinks = document.createElement('div');
      resourceLinks.className = 'resource-links';
      summaryData.resources.forEach(res => {
        const link = document.createElement('a');
        link.href = res.url;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = res.title;
        resourceLinks.appendChild(link);
      });
      resourcesCard.appendChild(resourceLinks);
      wrap.appendChild(resourcesCard);
    }
    
    // Certificate Section (if student name is present)
    if (state.student) {
      const certCard = document.createElement('div');
      certCard.className = 'completion-certificate card';
      const today = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
      certCard.innerHTML = `
        <h2>ðŸ† Certificate of Completion</h2>
        <div class="certificate-box">
          <h3>This certifies that</h3>
          <p class="student-name-display">${state.student}</p>
          <p>has successfully completed</p>
          <h4>${GUIDE_DATA.metadata.title}</h4>
          <p class="completion-date">Completed on: ${today}</p>
        </div>
      `;
      wrap.appendChild(certCard);
    }
    
    // Action Buttons
    const actions = document.createElement('div');
    actions.className = 'summary-actions';
    
    const restartBtn = document.createElement('button');
    restartBtn.className = 'secondary';
    restartBtn.textContent = 'ðŸ”„ Start Over';
    restartBtn.onclick = () => {
      if (confirm('Are you sure you want to reset all progress?')) {
        state.stageIndex = 0;
        state.sectionIndex = 0;
        state.completed = {};
        state.answers = {};
        state.showSummary = false;
        save();
        renderAll();
      }
    };
    
    const homeBtn = document.createElement('button');
    homeBtn.textContent = 'ðŸ  Back to Start';
    homeBtn.onclick = () => {
      state.stageIndex = 0;
      state.sectionIndex = 0;
      state.showSummary = false;
      save();
      renderAll();
    };
    
    const printBtn = document.createElement('button');
    printBtn.className = 'secondary';
    printBtn.textContent = 'ðŸ–¨ï¸ Print Summary';
    printBtn.onclick = () => window.print();
    
    actions.appendChild(homeBtn);
    actions.appendChild(printBtn);
    actions.appendChild(restartBtn);
    wrap.appendChild(actions);
    
    return wrap;
  }

  // ------------------------------
  // RENDERERS
  // ------------------------------
  function renderSidebar(){
    const host = el('#stageList'); host.innerHTML='';
    STAGES.forEach((s, si)=>{
      const det=document.createElement('details'); det.className='stage'; det.open = si===state.stageIndex;
      const sum=document.createElement('summary');
      sum.innerHTML = `<span>${s.title}</span><span class="badge">${Object.values(state.completed[s.id]||{}).filter(Boolean).length}/${SECTIONS.length}</span>`;
      det.appendChild(sum);
      const grid=document.createElement('div'); grid.className='section-links';
      SECTIONS.forEach((sec, ci)=>{
        const a=document.createElement('a'); a.href='#'; a.textContent=sec; if(sectionCompleted(s.id, sec)) a.classList.add('complete');
        a.onclick=(e)=>{ e.preventDefault(); state.stageIndex=si; state.sectionIndex=ci; save(); renderAll(); };
        grid.appendChild(a);
      });
      det.appendChild(grid); host.appendChild(det);
      
      // Accordion behavior: close other stages when this one opens
      det.addEventListener('toggle', ()=>{
        if(det.open){
          // Close all other stages
          host.querySelectorAll('.stage').forEach(otherStage => {
            if(otherStage !== det) otherStage.open = false;
          });
        }
      });
    });
  }

  function renderSection(stageId, section){
    const stageObj = GUIDE[stageId] || {};
    const secKey = section.replace(/\s+/g,'');
    const data = stageObj[secKey] || { h: section, components: [] };

    const wrap=document.createElement('div'); wrap.className='stage-section';
    const h=document.createElement('h1'); h.textContent=`${STAGES[state.stageIndex].title} â€” ${section}`; wrap.appendChild(h);
    
    // Collect context for this section (stage and section titles)
    const stageTitle = STAGES[state.stageIndex].title;
    const sectionTitle = section;
    
    // Process components from JSON structure
    // Track preceding text/code components for context
    const precedingContext = [];
    
    if(data.components && Array.isArray(data.components)) {
      data.components.forEach((comp, componentIndex) => {
        switch(comp.type) {
          case 'text':
            const p = document.createElement('p');
            p.innerHTML = parseMarkdown(comp.content);
            wrap.appendChild(p);
            // Add to context for subsequent questions
            precedingContext.push(comp.content);
            break;
          case 'code':
            wrap.appendChild(makeCopyBlock(comp.content));
            // Add code to context as well
            precedingContext.push(`Code example:\n${comp.content}`);
            break;
          case 'multipleChoice':
            const mcqData = {
              q: comp.question,
              options: comp.options,
              correct: comp.correctIndex
            };
            wrap.appendChild(mcqComponent(mcqData, stageId, section, componentIndex));
            break;
          case 'shortAnswer':
            const shortData = {
              prompt: comp.prompt,
              answerPattern: comp.validation?.pattern ? new RegExp(comp.validation.pattern) : undefined,
              answerContains: comp.validation?.acceptedAnswers,
              stageTitle: stageTitle,
              sectionTitle: sectionTitle,
              sectionContext: [...precedingContext] // Copy of context up to this point
            };
            wrap.appendChild(shortAnswerComponent(shortData, stageId, section, componentIndex));
            break;
          case 'checklist':
            wrap.appendChild(checklistComponent(comp.items, stageId, section, componentIndex));
            break;
          case 'ordering':
            wrap.appendChild(orderComponent(comp.items, stageId, section, componentIndex));
            break;
          case 'matching':
            const matchData = {
              left: comp.leftColumn,
              right: {}
            };
            comp.rightColumn.forEach(item => {
              matchData.right[item.definition] = item.matchesWith;
            });
            wrap.appendChild(matchComponent(matchData, stageId, section, componentIndex));
            break;
          case 'flowchart':
            wrap.appendChild(flowchartComponent(comp, stageId, section, componentIndex));
            break;
          case 'table':
            wrap.appendChild(tableComponent(comp, stageId, section, componentIndex));
            break;
        }
      });
    }

    const ctr=document.createElement('div'); ctr.className='flex space-between gap-12 no-print'; ctr.style.marginTop='14px';
      const left=document.createElement('div');
        const mark=document.createElement('button'); mark.className='mark-complete'; mark.textContent = sectionCompleted(stageId, section)? 'âœ“ Marked complete' : 'Mark section complete';
        mark.onclick=()=>{ const val = !sectionCompleted(stageId, section); markComplete(stageId, section, val); mark.textContent = val? 'âœ“ Marked complete':'Mark section complete'; };
        left.appendChild(mark);
      const right=document.createElement('div'); right.className='flex gap-8 right';
        const prev=document.createElement('button'); prev.className='secondary'; prev.textContent='â† Previous'; prev.onclick=()=>move(-1);
        const next=document.createElement('button'); next.textContent='Next â†’'; next.onclick=()=>move(1);
        right.appendChild(prev); right.appendChild(next);
    ctr.appendChild(left); ctr.appendChild(right);
    wrap.appendChild(ctr);

    return wrap;
  }

  function move(dir){
    let si=state.stageIndex, ci=state.sectionIndex;
    
    // Check if we're at Stage 6 (last stage), Transition section (last section), going forward
    if (dir > 0 && si === STAGES.length - 1 && ci === SECTIONS.length - 1) {
      // Show summary page
      state.showSummary = true;
      save();
      renderAll();
      return;
    }
    
    // Moving away from summary page
    state.showSummary = false;
    
    ci += dir;
    if(ci<0){ si=Math.max(0, si-1); ci=SECTIONS.length-1; }
    if(ci>=SECTIONS.length){ si=Math.min(STAGES.length-1, si+1); ci=0; }
    state.stageIndex=si; state.sectionIndex=ci; save(); renderAll();
  }

  function renderMain(){
    const contentEl = document.getElementById('content');
    contentEl.innerHTML='';
    
    // Show summary page if flag is set
    if (state.showSummary) {
      contentEl.appendChild(renderSummaryPage());
      return;
    }
    
    const stageId=STAGES[state.stageIndex].id;
    const section=SECTIONS[state.sectionIndex];
    contentEl.appendChild(renderSection(stageId, section));
  }

  function renderAll(){
    setBreadcrumbs();
    computeProgress();
    renderSidebar();
    renderMain();
  }

  // ------------------------------
  // INIT + EVENTS
  // ------------------------------
  document.getElementById('guideSelector').addEventListener('change', (e) => {
    const selectedGuide = e.target.value;
    localStorage.setItem('selected_guide', selectedGuide);
    loadGuide(selectedGuide);
  });

  document.getElementById('saveName').addEventListener('click', ()=>{
    const name = document.getElementById('studentName').value.trim();
    if(!name){ alert('Please enter a name'); return; }
    state.student = name; 
    localStorage.setItem('last_student_name', state.student);
    load(); save(); renderAll();
  });

  document.getElementById('printStage').addEventListener('click', ()=> window.print());

  document.getElementById('instructorBtn').addEventListener('click', ()=>{
    if(!state.instructor){
      const code = prompt('Enter instructor passcode:');
      const correctCode = GUIDE_DATA?.metadata?.instructorPasscode || 'abc123';
      if(code===correctCode){ state.instructor=true; alert('Instructor mode ON'); } else { alert('Incorrect passcode'); return; }
    } else {
      state.instructor=false; alert('Instructor mode OFF');
    }
    document.getElementById('instructorBtn').textContent = state.instructor? 'ON':'OFF';
    renderAll();
  });

  // default load
  state.student = localStorage.getItem('last_student_name') || '';
  if(state.student){ document.getElementById('studentName').value = state.student; }

  // Initialize guide selector and load first guide
  populateGuideSelector();
  </script>
</body>
</html>
